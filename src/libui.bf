// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by a forked CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
typealias __IntPtr = void*;

using internal libui;
namespace libui
{
    public enum UiForEach
    {
        UiForEachContinue = 0,
        UiForEachStop = 1
    }

    public enum UiWindowResizeEdge
    {
        UiWindowResizeEdgeLeft = 0,
        UiWindowResizeEdgeTop = 1,
        UiWindowResizeEdgeRight = 2,
        UiWindowResizeEdgeBottom = 3,
        UiWindowResizeEdgeTopLeft = 4,
        UiWindowResizeEdgeTopRight = 5,
        UiWindowResizeEdgeBottomLeft = 6,
        UiWindowResizeEdgeBottomRight = 7
    }

    public enum UiDrawBrushType
    {
        UiDrawBrushTypeSolid = 0,
        UiDrawBrushTypeLinearGradient = 1,
        UiDrawBrushTypeRadialGradient = 2,
        UiDrawBrushTypeImage = 3
    }

    public enum UiDrawLineCap
    {
        UiDrawLineCapFlat = 0,
        UiDrawLineCapRound = 1,
        UiDrawLineCapSquare = 2
    }

    public enum UiDrawLineJoin
    {
        UiDrawLineJoinMiter = 0,
        UiDrawLineJoinRound = 1,
        UiDrawLineJoinBevel = 2
    }

    public enum UiDrawFillMode
    {
        UiDrawFillModeWinding = 0,
        UiDrawFillModeAlternate = 1
    }

    public enum UiAttributeType
    {
        UiAttributeTypeFamily = 0,
        UiAttributeTypeSize = 1,
        UiAttributeTypeWeight = 2,
        UiAttributeTypeItalic = 3,
        UiAttributeTypeStretch = 4,
        UiAttributeTypeColor = 5,
        UiAttributeTypeBackground = 6,
        UiAttributeTypeUnderline = 7,
        UiAttributeTypeUnderlineColor = 8,
        UiAttributeTypeFeatures = 9
    }

    public enum UiTextWeight
    {
        UiTextWeightMinimum = 0,
        UiTextWeightThin = 100,
        UiTextWeightUltraLight = 200,
        UiTextWeightLight = 300,
        UiTextWeightBook = 350,
        UiTextWeightNormal = 400,
        UiTextWeightMedium = 500,
        UiTextWeightSemiBold = 600,
        UiTextWeightBold = 700,
        UiTextWeightUltraBold = 800,
        UiTextWeightHeavy = 900,
        UiTextWeightUltraHeavy = 950,
        UiTextWeightMaximum = 1000
    }

    public enum UiTextItalic
    {
        UiTextItalicNormal = 0,
        UiTextItalicOblique = 1,
        UiTextItalicItalic = 2
    }

    public enum UiTextStretch
    {
        UiTextStretchUltraCondensed = 0,
        UiTextStretchExtraCondensed = 1,
        UiTextStretchCondensed = 2,
        UiTextStretchSemiCondensed = 3,
        UiTextStretchNormal = 4,
        UiTextStretchSemiExpanded = 5,
        UiTextStretchExpanded = 6,
        UiTextStretchExtraExpanded = 7,
        UiTextStretchUltraExpanded = 8
    }

    public enum UiUnderline
    {
        UiUnderlineNone = 0,
        UiUnderlineSingle = 1,
        UiUnderlineDouble = 2,
        UiUnderlineSuggestion = 3
    }

    public enum UiUnderlineColor
    {
        UiUnderlineColorCustom = 0,
        UiUnderlineColorSpelling = 1,
        UiUnderlineColorGrammar = 2,
        UiUnderlineColorAuxiliary = 3
    }

    public enum UiDrawTextAlign
    {
        UiDrawTextAlignLeft = 0,
        UiDrawTextAlignCenter = 1,
        UiDrawTextAlignRight = 2
    }

    public enum UiModifier
    {
        /// <summary>Control key.</summary>
        UiModifierCtrl = 1,
        /// <summary>Alternate/Option key.</summary>
        UiModifierAlt = 2,
        /// <summary>Shift key.</summary>
        UiModifierShift = 4,
        /// <summary>Super/Command/Windows key.</summary>
        UiModifierSuper = 8
    }

    public enum UiExtKey
    {
        UiExtKeyEscape = 1,
        UiExtKeyInsert = 2,
        UiExtKeyDelete = 3,
        UiExtKeyHome = 4,
        UiExtKeyEnd = 5,
        UiExtKeyPageUp = 6,
        UiExtKeyPageDown = 7,
        UiExtKeyUp = 8,
        UiExtKeyDown = 9,
        UiExtKeyLeft = 10,
        UiExtKeyRight = 11,
        UiExtKeyF1 = 12,
        UiExtKeyF2 = 13,
        UiExtKeyF3 = 14,
        UiExtKeyF4 = 15,
        UiExtKeyF5 = 16,
        UiExtKeyF6 = 17,
        UiExtKeyF7 = 18,
        UiExtKeyF8 = 19,
        UiExtKeyF9 = 20,
        UiExtKeyF10 = 21,
        UiExtKeyF11 = 22,
        UiExtKeyF12 = 23,
        UiExtKeyN0 = 24,
        UiExtKeyN1 = 25,
        UiExtKeyN2 = 26,
        UiExtKeyN3 = 27,
        UiExtKeyN4 = 28,
        UiExtKeyN5 = 29,
        UiExtKeyN6 = 30,
        UiExtKeyN7 = 31,
        UiExtKeyN8 = 32,
        UiExtKeyN9 = 33,
        UiExtKeyNDot = 34,
        UiExtKeyNEnter = 35,
        UiExtKeyNAdd = 36,
        UiExtKeyNSubtract = 37,
        UiExtKeyNMultiply = 38,
        UiExtKeyNDivide = 39
    }

    public enum UiAlign
    {
        /// <summary>Fill area.</summary>
        UiAlignFill = 0,
        /// <summary>Place at start.</summary>
        UiAlignStart = 1,
        /// <summary>Place in center.</summary>
        UiAlignCenter = 2,
        /// <summary>Place at end.</summary>
        UiAlignEnd = 3
    }

    public enum UiAt
    {
        /// <summary>Place before control.</summary>
        UiAtLeading = 0,
        /// <summary>Place above control.</summary>
        UiAtTop = 1,
        /// <summary>Place behind control.</summary>
        UiAtTrailing = 2,
        /// <summary>Place below control.</summary>
        UiAtBottom = 3
    }

    public enum UiTableValueType
    {
        UiTableValueTypeString = 0,
        UiTableValueTypeImage = 1,
        UiTableValueTypeInt = 2,
        UiTableValueTypeColor = 3
    }

    public enum UiSortIndicator
    {
        UiSortIndicatorNone = 0,
        UiSortIndicatorAscending = 1,
        UiSortIndicatorDescending = 2
    }

    public enum UiTableSelectionMode
    {
        /// <summary>Allow no row selection.</summary>
        /// <remarks>
        /// <para>This mode disables all editing of text columns. Buttons</para>
        /// <para>and checkboxes keep working though.</para>
        /// </remarks>
        UiTableSelectionModeNone = 0,
        /// <summary>Allow zero or one row to be selected.</summary>
        UiTableSelectionModeZeroOrOne = 1,
        /// <summary>Allow for exactly one row to be selected.</summary>
        UiTableSelectionModeOne = 2,
        /// <summary>Allow zero or many (multiple) rows to be selected.</summary>
        UiTableSelectionModeZeroOrMany = 3
    }

    /// <summary>Base class for GUI controls providing common methods.</summary>
    public delegate uint32 UiOpenTypeFeaturesForEachFunc(__IntPtr otf, int8 a, int8 b, int8 c, int8 d, uint32 value, __IntPtr data);

    public delegate uint32 UiAttributedStringForEachAttributeFunc(__IntPtr s, __IntPtr a, uint64 start, uint64 end, __IntPtr data);

    /// <summary>Developer defined methods for data retrieval and setting.</summary>
    /// <remarks>
    /// <para>These methods get called whenever the associated uiTableModel needs to</para>
    /// <para>retrieve data or a uiTable wants to set data.</para>
    /// <para>These methods are NOT allowed to change as soon as the</para>
    /// <para>uiTableModelHandler is associated with a uiTableModel.</para>
    /// <para>Validate ranges</para>
    /// <para>Validate types on each getter/setter call (? table columns only?)</para>
    /// </remarks>
    /// <summary>Optional parameters to control the appearance of text columns.</summary>
    /// <summary>Table parameters passed to uiNewTable().</summary>
    /// <summary>Holds an array of selected row indices for a table.</summary>
    public class UiInitOptions
    {
        [CRepr]
        public struct __Internal
        {
            internal uint64 Size;

            [LinkName("??0uiInitOptions@@QEAA@AEBU0@@Z"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiInitOptions>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiInitOptions managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiInitOptions managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiInitOptions __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiInitOptions(native, skipVTables);
        }

        internal static UiInitOptions __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiInitOptions managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiInitOptions GetInstance(__IntPtr native)
        {
            UiInitOptions managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiInitOptions __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiInitOptions(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }

        public this()
        {
            __Instance = Internal.Malloc(sizeof(libui.UiInitOptions.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public this(libui.UiInitOptions _0)
        {
            __Instance = Internal.Malloc(sizeof(libui.UiInitOptions.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((libui.UiInitOptions.__Internal*) __Instance) = *((libui.UiInitOptions.__Internal*) _0.__Instance);
        }

        ~this()
        {
            if (__Instance == null)
                return;
            if (__ownsNativeInstance)
                Internal.Free(__Instance);
            UiInitOptions managed;
            if (__TryGetNativeToManagedMapping(__Instance, out managed))
                __RecordNativeToManagedMapping(__Instance, null);

            __Instance = null;
        }

        public uint64 Size
        {
            get
            {
                return ((__Internal*)__Instance).Size;
            }

            set
            {
                ((__Internal*)__Instance).Size = value;
            }
        }
    }

    public class UiWindow
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiWindow>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiWindow managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiWindow managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiWindow __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiWindow(native, skipVTables);
        }

        internal static UiWindow __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiWindow managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiWindow GetInstance(__IntPtr native)
        {
            UiWindow managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiWindow __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiWindow(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiButton
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiButton>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiButton managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiButton managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiButton __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiButton(native, skipVTables);
        }

        internal static UiButton __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiButton managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiButton GetInstance(__IntPtr native)
        {
            UiButton managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiButton __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiButton(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiBox
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiBox>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiBox managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiBox managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiBox __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiBox(native, skipVTables);
        }

        internal static UiBox __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiBox managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiBox GetInstance(__IntPtr native)
        {
            UiBox managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiBox __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiBox(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiCheckbox
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiCheckbox>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiCheckbox managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiCheckbox managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiCheckbox __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiCheckbox(native, skipVTables);
        }

        internal static UiCheckbox __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiCheckbox managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiCheckbox GetInstance(__IntPtr native)
        {
            UiCheckbox managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiCheckbox __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiCheckbox(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiEntry
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiEntry>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiEntry managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiEntry managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiEntry __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiEntry(native, skipVTables);
        }

        internal static UiEntry __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiEntry managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiEntry GetInstance(__IntPtr native)
        {
            UiEntry managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiEntry __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiEntry(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiLabel
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiLabel>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiLabel managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiLabel managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiLabel __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiLabel(native, skipVTables);
        }

        internal static UiLabel __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiLabel managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiLabel GetInstance(__IntPtr native)
        {
            UiLabel managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiLabel __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiLabel(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiTab
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiTab>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiTab managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiTab managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiTab __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiTab(native, skipVTables);
        }

        internal static UiTab __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiTab managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiTab GetInstance(__IntPtr native)
        {
            UiTab managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiTab __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiTab(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiGroup
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiGroup>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiGroup managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiGroup managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiGroup __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiGroup(native, skipVTables);
        }

        internal static UiGroup __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiGroup managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiGroup GetInstance(__IntPtr native)
        {
            UiGroup managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiGroup __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiGroup(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiSpinbox
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiSpinbox>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiSpinbox managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiSpinbox managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiSpinbox __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiSpinbox(native, skipVTables);
        }

        internal static UiSpinbox __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiSpinbox managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiSpinbox GetInstance(__IntPtr native)
        {
            UiSpinbox managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiSpinbox __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiSpinbox(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiSlider
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiSlider>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiSlider managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiSlider managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiSlider __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiSlider(native, skipVTables);
        }

        internal static UiSlider __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiSlider managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiSlider GetInstance(__IntPtr native)
        {
            UiSlider managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiSlider __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiSlider(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiProgressBar
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiProgressBar>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiProgressBar managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiProgressBar managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiProgressBar __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiProgressBar(native, skipVTables);
        }

        internal static UiProgressBar __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiProgressBar managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiProgressBar GetInstance(__IntPtr native)
        {
            UiProgressBar managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiProgressBar __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiProgressBar(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiSeparator
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiSeparator>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiSeparator managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiSeparator managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiSeparator __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiSeparator(native, skipVTables);
        }

        internal static UiSeparator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiSeparator managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiSeparator GetInstance(__IntPtr native)
        {
            UiSeparator managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiSeparator __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiSeparator(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiCombobox
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiCombobox>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiCombobox managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiCombobox managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiCombobox __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiCombobox(native, skipVTables);
        }

        internal static UiCombobox __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiCombobox managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiCombobox GetInstance(__IntPtr native)
        {
            UiCombobox managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiCombobox __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiCombobox(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiEditableCombobox
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiEditableCombobox>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiEditableCombobox managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiEditableCombobox managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiEditableCombobox __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiEditableCombobox(native, skipVTables);
        }

        internal static UiEditableCombobox __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiEditableCombobox managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiEditableCombobox GetInstance(__IntPtr native)
        {
            UiEditableCombobox managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiEditableCombobox __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiEditableCombobox(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiRadioButtons
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiRadioButtons>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiRadioButtons managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiRadioButtons managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiRadioButtons __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiRadioButtons(native, skipVTables);
        }

        internal static UiRadioButtons __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiRadioButtons managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiRadioButtons GetInstance(__IntPtr native)
        {
            UiRadioButtons managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiRadioButtons __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiRadioButtons(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class Tm
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.Tm>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.Tm managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.Tm managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Tm __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  Tm(native, skipVTables);
        }

        internal static Tm __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            Tm managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static Tm GetInstance(__IntPtr native)
        {
            Tm managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static Tm __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Tm(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiDateTimePicker
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiDateTimePicker>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiDateTimePicker managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiDateTimePicker managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiDateTimePicker __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiDateTimePicker(native, skipVTables);
        }

        internal static UiDateTimePicker __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiDateTimePicker managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiDateTimePicker GetInstance(__IntPtr native)
        {
            UiDateTimePicker managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiDateTimePicker __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiDateTimePicker(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiMultilineEntry
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiMultilineEntry>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiMultilineEntry managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiMultilineEntry managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiMultilineEntry __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiMultilineEntry(native, skipVTables);
        }

        internal static UiMultilineEntry __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiMultilineEntry managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiMultilineEntry GetInstance(__IntPtr native)
        {
            UiMultilineEntry managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiMultilineEntry __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiMultilineEntry(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiMenuItem
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiMenuItem>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiMenuItem managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiMenuItem managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiMenuItem __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiMenuItem(native, skipVTables);
        }

        internal static UiMenuItem __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiMenuItem managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiMenuItem GetInstance(__IntPtr native)
        {
            UiMenuItem managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiMenuItem __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiMenuItem(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiMenu
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiMenu>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiMenu managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiMenu managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiMenu __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiMenu(native, skipVTables);
        }

        internal static UiMenu __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiMenu managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiMenu GetInstance(__IntPtr native)
        {
            UiMenu managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiMenu __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiMenu(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiArea
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiArea>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiArea managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiArea managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiArea __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiArea(native, skipVTables);
        }

        internal static UiArea __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiArea managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiArea GetInstance(__IntPtr native)
        {
            UiArea managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiArea __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiArea(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiDrawContext
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiDrawContext>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiDrawContext managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiDrawContext managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiDrawContext __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiDrawContext(native, skipVTables);
        }

        internal static UiDrawContext __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiDrawContext managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiDrawContext GetInstance(__IntPtr native)
        {
            UiDrawContext managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiDrawContext __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiDrawContext(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiDrawPath
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiDrawPath>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiDrawPath managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiDrawPath managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiDrawPath __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiDrawPath(native, skipVTables);
        }

        internal static UiDrawPath __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiDrawPath managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiDrawPath GetInstance(__IntPtr native)
        {
            UiDrawPath managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiDrawPath __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiDrawPath(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiAttribute
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiAttribute>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiAttribute managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiAttribute managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiAttribute __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiAttribute(native, skipVTables);
        }

        internal static UiAttribute __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiAttribute managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiAttribute GetInstance(__IntPtr native)
        {
            UiAttribute managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiAttribute __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiAttribute(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiOpenTypeFeatures
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiOpenTypeFeatures>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiOpenTypeFeatures managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiOpenTypeFeatures managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiOpenTypeFeatures __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiOpenTypeFeatures(native, skipVTables);
        }

        internal static UiOpenTypeFeatures __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiOpenTypeFeatures managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiOpenTypeFeatures GetInstance(__IntPtr native)
        {
            UiOpenTypeFeatures managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiOpenTypeFeatures __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiOpenTypeFeatures(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiAttributedString
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiAttributedString>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiAttributedString managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiAttributedString managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiAttributedString __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiAttributedString(native, skipVTables);
        }

        internal static UiAttributedString __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiAttributedString managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiAttributedString GetInstance(__IntPtr native)
        {
            UiAttributedString managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiAttributedString __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiAttributedString(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiDrawTextLayout
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiDrawTextLayout>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiDrawTextLayout managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiDrawTextLayout managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiDrawTextLayout __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiDrawTextLayout(native, skipVTables);
        }

        internal static UiDrawTextLayout __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiDrawTextLayout managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiDrawTextLayout GetInstance(__IntPtr native)
        {
            UiDrawTextLayout managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiDrawTextLayout __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiDrawTextLayout(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiFontButton
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiFontButton>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiFontButton managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiFontButton managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiFontButton __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiFontButton(native, skipVTables);
        }

        internal static UiFontButton __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiFontButton managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiFontButton GetInstance(__IntPtr native)
        {
            UiFontButton managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiFontButton __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiFontButton(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiColorButton
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiColorButton>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiColorButton managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiColorButton managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiColorButton __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiColorButton(native, skipVTables);
        }

        internal static UiColorButton __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiColorButton managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiColorButton GetInstance(__IntPtr native)
        {
            UiColorButton managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiColorButton __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiColorButton(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiForm
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiForm>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiForm managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiForm managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiForm __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiForm(native, skipVTables);
        }

        internal static UiForm __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiForm managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiForm GetInstance(__IntPtr native)
        {
            UiForm managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiForm __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiForm(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiGrid
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiGrid>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiGrid managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiGrid managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiGrid __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiGrid(native, skipVTables);
        }

        internal static UiGrid __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiGrid managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiGrid GetInstance(__IntPtr native)
        {
            UiGrid managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiGrid __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiGrid(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiImage
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiImage>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiImage managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiImage managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiImage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiImage(native, skipVTables);
        }

        internal static UiImage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiImage managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiImage GetInstance(__IntPtr native)
        {
            UiImage managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiImage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiImage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiTableValue
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiTableValue>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiTableValue managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiTableValue managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiTableValue __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiTableValue(native, skipVTables);
        }

        internal static UiTableValue __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiTableValue managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiTableValue GetInstance(__IntPtr native)
        {
            UiTableValue managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiTableValue __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiTableValue(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiTableModel
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiTableModel>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiTableModel managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiTableModel managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiTableModel __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiTableModel(native, skipVTables);
        }

        internal static UiTableModel __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiTableModel managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiTableModel GetInstance(__IntPtr native)
        {
            UiTableModel managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiTableModel __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiTableModel(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiTable
    {
        public struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiTable>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiTable managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiTable managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiTable __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiTable(native, skipVTables);
        }

        internal static UiTable __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiTable managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiTable GetInstance(__IntPtr native)
        {
            UiTable managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiTable __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiTable(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }
    }

    public class UiControl
    {
        [CRepr]
        public struct __Internal
        {
            internal uint32 Signature;
            internal uint32 OSSignature;
            internal uint32 TypeSignature;
            internal __IntPtr Destroy;
            internal __IntPtr Handle;
            internal __IntPtr Parent;
            internal __IntPtr SetParent;
            internal __IntPtr Toplevel;
            internal __IntPtr Visible;
            internal __IntPtr Show;
            internal __IntPtr Hide;
            internal __IntPtr Enabled;
            internal __IntPtr Enable;
            internal __IntPtr Disable;

            [LinkName("??0uiControl@@QEAA@AEBU0@@Z"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiControl>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiControl managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiControl managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiControl __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiControl(native, skipVTables);
        }

        internal static UiControl __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiControl managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiControl GetInstance(__IntPtr native)
        {
            UiControl managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiControl __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiControl(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }

        public this()
        {
            __Instance = Internal.Malloc(sizeof(libui.UiControl.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public this(libui.UiControl _0)
        {
            __Instance = Internal.Malloc(sizeof(libui.UiControl.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((libui.UiControl.__Internal*) __Instance) = *((libui.UiControl.__Internal*) _0.__Instance);
        }

        ~this()
        {
            if (__Instance == null)
                return;
            if (__ownsNativeInstance)
                Internal.Free(__Instance);
            UiControl managed;
            if (__TryGetNativeToManagedMapping(__Instance, out managed))
                __RecordNativeToManagedMapping(__Instance, null);

            __Instance = null;
        }

        public uint32 Signature
        {
            get
            {
                return ((__Internal*)__Instance).Signature;
            }

            set
            {
                ((__Internal*)__Instance).Signature = value;
            }
        }

        public uint32 OSSignature
        {
            get
            {
                return ((__Internal*)__Instance).OSSignature;
            }

            set
            {
                ((__Internal*)__Instance).OSSignature = value;
            }
        }

        public uint32 TypeSignature
        {
            get
            {
                return ((__Internal*)__Instance).TypeSignature;
            }

            set
            {
                ((__Internal*)__Instance).TypeSignature = value;
            }
        }

        public libui.Delegates.Action___IntPtr Destroy
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).Destroy;
                return __ptr0 == null? null : *(libui.Delegates.Action___IntPtr*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).Destroy = value == null ? null : value.GetFuncPtr();
            }
        }

        public libui.Delegates.Func_ulong___IntPtr Handle
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).Handle;
                return __ptr0 == null? null : *(libui.Delegates.Func_ulong___IntPtr*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).Handle = value == null ? null : value.GetFuncPtr();
            }
        }

        public libui.Delegates.Func___IntPtr___IntPtr Parent
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).Parent;
                return __ptr0 == null? null : *(libui.Delegates.Func___IntPtr___IntPtr*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).Parent = value == null ? null : value.GetFuncPtr();
            }
        }

        public libui.Delegates.Action___IntPtr___IntPtr SetParent
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).SetParent;
                return __ptr0 == null? null : *(libui.Delegates.Action___IntPtr___IntPtr*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).SetParent = value == null ? null : value.GetFuncPtr();
            }
        }

        public libui.Delegates.Func_int___IntPtr Toplevel
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).Toplevel;
                return __ptr0 == null? null : *(libui.Delegates.Func_int___IntPtr*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).Toplevel = value == null ? null : value.GetFuncPtr();
            }
        }

        public libui.Delegates.Func_int___IntPtr Visible
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).Visible;
                return __ptr0 == null? null : *(libui.Delegates.Func_int___IntPtr*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).Visible = value == null ? null : value.GetFuncPtr();
            }
        }

        public libui.Delegates.Action___IntPtr Show
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).Show;
                return __ptr0 == null? null : *(libui.Delegates.Action___IntPtr*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).Show = value == null ? null : value.GetFuncPtr();
            }
        }

        public libui.Delegates.Action___IntPtr Hide
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).Hide;
                return __ptr0 == null? null : *(libui.Delegates.Action___IntPtr*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).Hide = value == null ? null : value.GetFuncPtr();
            }
        }

        public libui.Delegates.Func_int___IntPtr Enabled
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).Enabled;
                return __ptr0 == null? null : *(libui.Delegates.Func_int___IntPtr*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).Enabled = value == null ? null : value.GetFuncPtr();
            }
        }

        public libui.Delegates.Action___IntPtr Enable
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).Enable;
                return __ptr0 == null? null : *(libui.Delegates.Action___IntPtr*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).Enable = value == null ? null : value.GetFuncPtr();
            }
        }

        public libui.Delegates.Action___IntPtr Disable
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).Disable;
                return __ptr0 == null? null : *(libui.Delegates.Action___IntPtr*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).Disable = value == null ? null : value.GetFuncPtr();
            }
        }
    }

    public class UiAreaHandler
    {
        [CRepr]
        public struct __Internal
        {
            internal __IntPtr Draw;
            internal __IntPtr MouseEvent;
            internal __IntPtr MouseCrossed;
            internal __IntPtr DragBroken;
            internal __IntPtr KeyEvent;

            [LinkName("??0uiAreaHandler@@QEAA@AEBU0@@Z"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiAreaHandler>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiAreaHandler managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiAreaHandler managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiAreaHandler __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiAreaHandler(native, skipVTables);
        }

        internal static UiAreaHandler __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiAreaHandler managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiAreaHandler GetInstance(__IntPtr native)
        {
            UiAreaHandler managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiAreaHandler __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiAreaHandler(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }

        public this()
        {
            __Instance = Internal.Malloc(sizeof(libui.UiAreaHandler.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public this(libui.UiAreaHandler _0)
        {
            __Instance = Internal.Malloc(sizeof(libui.UiAreaHandler.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((libui.UiAreaHandler.__Internal*) __Instance) = *((libui.UiAreaHandler.__Internal*) _0.__Instance);
        }

        ~this()
        {
            if (__Instance == null)
                return;
            if (__ownsNativeInstance)
                Internal.Free(__Instance);
            UiAreaHandler managed;
            if (__TryGetNativeToManagedMapping(__Instance, out managed))
                __RecordNativeToManagedMapping(__Instance, null);

            __Instance = null;
        }

        public libui.Delegates.Action___IntPtr___IntPtr___IntPtr Draw
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).Draw;
                return __ptr0 == null? null : *(libui.Delegates.Action___IntPtr___IntPtr___IntPtr*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).Draw = value == null ? null : value.GetFuncPtr();
            }
        }

        public libui.Delegates.Action___IntPtr___IntPtr___IntPtr MouseEvent
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).MouseEvent;
                return __ptr0 == null? null : *(libui.Delegates.Action___IntPtr___IntPtr___IntPtr*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).MouseEvent = value == null ? null : value.GetFuncPtr();
            }
        }

        public libui.Delegates.Action___IntPtr___IntPtr_int MouseCrossed
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).MouseCrossed;
                return __ptr0 == null? null : *(libui.Delegates.Action___IntPtr___IntPtr_int*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).MouseCrossed = value == null ? null : value.GetFuncPtr();
            }
        }

        public libui.Delegates.Action___IntPtr___IntPtr DragBroken
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).DragBroken;
                return __ptr0 == null? null : *(libui.Delegates.Action___IntPtr___IntPtr*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).DragBroken = value == null ? null : value.GetFuncPtr();
            }
        }

        public libui.Delegates.Func_int___IntPtr___IntPtr___IntPtr KeyEvent
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).KeyEvent;
                return __ptr0 == null? null : *(libui.Delegates.Func_int___IntPtr___IntPtr___IntPtr*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).KeyEvent = value == null ? null : value.GetFuncPtr();
            }
        }
    }

    public class UiAreaDrawParams
    {
        [CRepr]
        public struct __Internal
        {
            internal __IntPtr Context;
            internal double AreaWidth;
            internal double AreaHeight;
            internal double ClipX;
            internal double ClipY;
            internal double ClipWidth;
            internal double ClipHeight;

            [LinkName("??0uiAreaDrawParams@@QEAA@AEBU0@@Z"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiAreaDrawParams>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiAreaDrawParams managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiAreaDrawParams managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiAreaDrawParams __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiAreaDrawParams(native, skipVTables);
        }

        internal static UiAreaDrawParams __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiAreaDrawParams managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiAreaDrawParams GetInstance(__IntPtr native)
        {
            UiAreaDrawParams managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiAreaDrawParams __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiAreaDrawParams(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }

        public this()
        {
            __Instance = Internal.Malloc(sizeof(libui.UiAreaDrawParams.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public this(libui.UiAreaDrawParams _0)
        {
            __Instance = Internal.Malloc(sizeof(libui.UiAreaDrawParams.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((libui.UiAreaDrawParams.__Internal*) __Instance) = *((libui.UiAreaDrawParams.__Internal*) _0.__Instance);
        }

        ~this()
        {
            if (__Instance == null)
                return;
            if (__ownsNativeInstance)
                Internal.Free(__Instance);
            UiAreaDrawParams managed;
            if (__TryGetNativeToManagedMapping(__Instance, out managed))
                __RecordNativeToManagedMapping(__Instance, null);

            __Instance = null;
        }

        public libui.UiDrawContext Context
        {
            get
            {
                var __result0 = libui.UiDrawContext.__GetOrCreateInstance(((__Internal*)__Instance).Context, true);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance).Context = value == null ? null : value.__Instance;
            }
        }

        public double AreaWidth
        {
            get
            {
                return ((__Internal*)__Instance).AreaWidth;
            }

            set
            {
                ((__Internal*)__Instance).AreaWidth = value;
            }
        }

        public double AreaHeight
        {
            get
            {
                return ((__Internal*)__Instance).AreaHeight;
            }

            set
            {
                ((__Internal*)__Instance).AreaHeight = value;
            }
        }

        public double ClipX
        {
            get
            {
                return ((__Internal*)__Instance).ClipX;
            }

            set
            {
                ((__Internal*)__Instance).ClipX = value;
            }
        }

        public double ClipY
        {
            get
            {
                return ((__Internal*)__Instance).ClipY;
            }

            set
            {
                ((__Internal*)__Instance).ClipY = value;
            }
        }

        public double ClipWidth
        {
            get
            {
                return ((__Internal*)__Instance).ClipWidth;
            }

            set
            {
                ((__Internal*)__Instance).ClipWidth = value;
            }
        }

        public double ClipHeight
        {
            get
            {
                return ((__Internal*)__Instance).ClipHeight;
            }

            set
            {
                ((__Internal*)__Instance).ClipHeight = value;
            }
        }
    }

    public class UiDrawMatrix
    {
        [CRepr]
        public struct __Internal
        {
            internal double M11;
            internal double M12;
            internal double M21;
            internal double M22;
            internal double M31;
            internal double M32;

            [LinkName("??0uiDrawMatrix@@QEAA@AEBU0@@Z"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiDrawMatrix>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiDrawMatrix managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiDrawMatrix managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiDrawMatrix __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiDrawMatrix(native, skipVTables);
        }

        internal static UiDrawMatrix __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiDrawMatrix managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiDrawMatrix GetInstance(__IntPtr native)
        {
            UiDrawMatrix managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiDrawMatrix __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiDrawMatrix(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }

        public this()
        {
            __Instance = Internal.Malloc(sizeof(libui.UiDrawMatrix.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public this(libui.UiDrawMatrix _0)
        {
            __Instance = Internal.Malloc(sizeof(libui.UiDrawMatrix.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((libui.UiDrawMatrix.__Internal*) __Instance) = *((libui.UiDrawMatrix.__Internal*) _0.__Instance);
        }

        ~this()
        {
            if (__Instance == null)
                return;
            if (__ownsNativeInstance)
                Internal.Free(__Instance);
            UiDrawMatrix managed;
            if (__TryGetNativeToManagedMapping(__Instance, out managed))
                __RecordNativeToManagedMapping(__Instance, null);

            __Instance = null;
        }

        public double M11
        {
            get
            {
                return ((__Internal*)__Instance).M11;
            }

            set
            {
                ((__Internal*)__Instance).M11 = value;
            }
        }

        public double M12
        {
            get
            {
                return ((__Internal*)__Instance).M12;
            }

            set
            {
                ((__Internal*)__Instance).M12 = value;
            }
        }

        public double M21
        {
            get
            {
                return ((__Internal*)__Instance).M21;
            }

            set
            {
                ((__Internal*)__Instance).M21 = value;
            }
        }

        public double M22
        {
            get
            {
                return ((__Internal*)__Instance).M22;
            }

            set
            {
                ((__Internal*)__Instance).M22 = value;
            }
        }

        public double M31
        {
            get
            {
                return ((__Internal*)__Instance).M31;
            }

            set
            {
                ((__Internal*)__Instance).M31 = value;
            }
        }

        public double M32
        {
            get
            {
                return ((__Internal*)__Instance).M32;
            }

            set
            {
                ((__Internal*)__Instance).M32 = value;
            }
        }
    }

    public class UiDrawBrush
    {
        [CRepr]
        public struct __Internal
        {
            internal uint32 Type;
            internal double R;
            internal double G;
            internal double B;
            internal double A;
            internal double X0;
            internal double Y0;
            internal double X1;
            internal double Y1;
            internal double OuterRadius;
            internal __IntPtr Stops;
            internal uint64 NumStops;

            [LinkName("??0uiDrawBrush@@QEAA@AEBU0@@Z"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiDrawBrush>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiDrawBrush managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiDrawBrush managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiDrawBrush __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiDrawBrush(native, skipVTables);
        }

        internal static UiDrawBrush __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiDrawBrush managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiDrawBrush GetInstance(__IntPtr native)
        {
            UiDrawBrush managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiDrawBrush __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiDrawBrush(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }

        public this()
        {
            __Instance = Internal.Malloc(sizeof(libui.UiDrawBrush.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public this(libui.UiDrawBrush _0)
        {
            __Instance = Internal.Malloc(sizeof(libui.UiDrawBrush.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((libui.UiDrawBrush.__Internal*) __Instance) = *((libui.UiDrawBrush.__Internal*) _0.__Instance);
        }

        ~this()
        {
            if (__Instance == null)
                return;
            if (__ownsNativeInstance)
                Internal.Free(__Instance);
            UiDrawBrush managed;
            if (__TryGetNativeToManagedMapping(__Instance, out managed))
                __RecordNativeToManagedMapping(__Instance, null);

            __Instance = null;
        }

        public uint32 Type
        {
            get
            {
                return ((__Internal*)__Instance).Type;
            }

            set
            {
                ((__Internal*)__Instance).Type = value;
            }
        }

        public double R
        {
            get
            {
                return ((__Internal*)__Instance).R;
            }

            set
            {
                ((__Internal*)__Instance).R = value;
            }
        }

        public double G
        {
            get
            {
                return ((__Internal*)__Instance).G;
            }

            set
            {
                ((__Internal*)__Instance).G = value;
            }
        }

        public double B
        {
            get
            {
                return ((__Internal*)__Instance).B;
            }

            set
            {
                ((__Internal*)__Instance).B = value;
            }
        }

        public double A
        {
            get
            {
                return ((__Internal*)__Instance).A;
            }

            set
            {
                ((__Internal*)__Instance).A = value;
            }
        }

        public double X0
        {
            get
            {
                return ((__Internal*)__Instance).X0;
            }

            set
            {
                ((__Internal*)__Instance).X0 = value;
            }
        }

        public double Y0
        {
            get
            {
                return ((__Internal*)__Instance).Y0;
            }

            set
            {
                ((__Internal*)__Instance).Y0 = value;
            }
        }

        public double X1
        {
            get
            {
                return ((__Internal*)__Instance).X1;
            }

            set
            {
                ((__Internal*)__Instance).X1 = value;
            }
        }

        public double Y1
        {
            get
            {
                return ((__Internal*)__Instance).Y1;
            }

            set
            {
                ((__Internal*)__Instance).Y1 = value;
            }
        }

        public double OuterRadius
        {
            get
            {
                return ((__Internal*)__Instance).OuterRadius;
            }

            set
            {
                ((__Internal*)__Instance).OuterRadius = value;
            }
        }

        public libui.UiDrawBrushGradientStop Stops
        {
            get
            {
                var __result0 = libui.UiDrawBrushGradientStop.__GetOrCreateInstance(((__Internal*)__Instance).Stops, true);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance).Stops = value == null ? null : value.__Instance;
            }
        }

        public uint64 NumStops
        {
            get
            {
                return ((__Internal*)__Instance).NumStops;
            }

            set
            {
                ((__Internal*)__Instance).NumStops = value;
            }
        }
    }

    public class UiDrawBrushGradientStop
    {
        [CRepr]
        public struct __Internal
        {
            internal double Pos;
            internal double R;
            internal double G;
            internal double B;
            internal double A;

            [LinkName("??0uiDrawBrushGradientStop@@QEAA@AEBU0@@Z"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiDrawBrushGradientStop>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiDrawBrushGradientStop managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiDrawBrushGradientStop managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiDrawBrushGradientStop __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiDrawBrushGradientStop(native, skipVTables);
        }

        internal static UiDrawBrushGradientStop __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiDrawBrushGradientStop managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiDrawBrushGradientStop GetInstance(__IntPtr native)
        {
            UiDrawBrushGradientStop managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiDrawBrushGradientStop __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiDrawBrushGradientStop(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }

        public this()
        {
            __Instance = Internal.Malloc(sizeof(libui.UiDrawBrushGradientStop.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public this(libui.UiDrawBrushGradientStop _0)
        {
            __Instance = Internal.Malloc(sizeof(libui.UiDrawBrushGradientStop.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((libui.UiDrawBrushGradientStop.__Internal*) __Instance) = *((libui.UiDrawBrushGradientStop.__Internal*) _0.__Instance);
        }

        ~this()
        {
            if (__Instance == null)
                return;
            if (__ownsNativeInstance)
                Internal.Free(__Instance);
            UiDrawBrushGradientStop managed;
            if (__TryGetNativeToManagedMapping(__Instance, out managed))
                __RecordNativeToManagedMapping(__Instance, null);

            __Instance = null;
        }

        public double Pos
        {
            get
            {
                return ((__Internal*)__Instance).Pos;
            }

            set
            {
                ((__Internal*)__Instance).Pos = value;
            }
        }

        public double R
        {
            get
            {
                return ((__Internal*)__Instance).R;
            }

            set
            {
                ((__Internal*)__Instance).R = value;
            }
        }

        public double G
        {
            get
            {
                return ((__Internal*)__Instance).G;
            }

            set
            {
                ((__Internal*)__Instance).G = value;
            }
        }

        public double B
        {
            get
            {
                return ((__Internal*)__Instance).B;
            }

            set
            {
                ((__Internal*)__Instance).B = value;
            }
        }

        public double A
        {
            get
            {
                return ((__Internal*)__Instance).A;
            }

            set
            {
                ((__Internal*)__Instance).A = value;
            }
        }
    }

    public class UiDrawStrokeParams
    {
        [CRepr]
        public struct __Internal
        {
            internal uint32 Cap;
            internal uint32 Join;
            internal double Thickness;
            internal double MiterLimit;
            internal __IntPtr Dashes;
            internal uint64 NumDashes;
            internal double DashPhase;

            [LinkName("??0uiDrawStrokeParams@@QEAA@AEBU0@@Z"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiDrawStrokeParams>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiDrawStrokeParams managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiDrawStrokeParams managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiDrawStrokeParams __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiDrawStrokeParams(native, skipVTables);
        }

        internal static UiDrawStrokeParams __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiDrawStrokeParams managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiDrawStrokeParams GetInstance(__IntPtr native)
        {
            UiDrawStrokeParams managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiDrawStrokeParams __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiDrawStrokeParams(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }

        public this()
        {
            __Instance = Internal.Malloc(sizeof(libui.UiDrawStrokeParams.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public this(libui.UiDrawStrokeParams _0)
        {
            __Instance = Internal.Malloc(sizeof(libui.UiDrawStrokeParams.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((libui.UiDrawStrokeParams.__Internal*) __Instance) = *((libui.UiDrawStrokeParams.__Internal*) _0.__Instance);
        }

        ~this()
        {
            if (__Instance == null)
                return;
            if (__ownsNativeInstance)
                Internal.Free(__Instance);
            UiDrawStrokeParams managed;
            if (__TryGetNativeToManagedMapping(__Instance, out managed))
                __RecordNativeToManagedMapping(__Instance, null);

            __Instance = null;
        }

        public uint32 Cap
        {
            get
            {
                return ((__Internal*)__Instance).Cap;
            }

            set
            {
                ((__Internal*)__Instance).Cap = value;
            }
        }

        public uint32 Join
        {
            get
            {
                return ((__Internal*)__Instance).Join;
            }

            set
            {
                ((__Internal*)__Instance).Join = value;
            }
        }

        public double Thickness
        {
            get
            {
                return ((__Internal*)__Instance).Thickness;
            }

            set
            {
                ((__Internal*)__Instance).Thickness = value;
            }
        }

        public double MiterLimit
        {
            get
            {
                return ((__Internal*)__Instance).MiterLimit;
            }

            set
            {
                ((__Internal*)__Instance).MiterLimit = value;
            }
        }

        public double* Dashes
        {
            get
            {
                return (double*) ((__Internal*)__Instance).Dashes;
            }

            set
            {
                ((__Internal*)__Instance).Dashes = (__IntPtr) value;
            }
        }

        public uint64 NumDashes
        {
            get
            {
                return ((__Internal*)__Instance).NumDashes;
            }

            set
            {
                ((__Internal*)__Instance).NumDashes = value;
            }
        }

        public double DashPhase
        {
            get
            {
                return ((__Internal*)__Instance).DashPhase;
            }

            set
            {
                ((__Internal*)__Instance).DashPhase = value;
            }
        }
    }

    public class UiFontDescriptor
    {
        [CRepr]
        public struct __Internal
        {
            internal __IntPtr Family;
            internal double Size;
            internal uint32 Weight;
            internal uint32 Italic;
            internal uint32 Stretch;

            [LinkName("??0uiFontDescriptor@@QEAA@AEBU0@@Z"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiFontDescriptor>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiFontDescriptor managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiFontDescriptor managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiFontDescriptor __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiFontDescriptor(native, skipVTables);
        }

        internal static UiFontDescriptor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiFontDescriptor managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiFontDescriptor GetInstance(__IntPtr native)
        {
            UiFontDescriptor managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiFontDescriptor __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiFontDescriptor(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }

        public this()
        {
            __Instance = Internal.Malloc(sizeof(libui.UiFontDescriptor.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public this(libui.UiFontDescriptor _0)
        {
            __Instance = Internal.Malloc(sizeof(libui.UiFontDescriptor.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((libui.UiFontDescriptor.__Internal*) __Instance) = *((libui.UiFontDescriptor.__Internal*) _0.__Instance);
        }

        ~this()
        {
            if (__Instance == null)
                return;
            if (__ownsNativeInstance)
                Internal.Free(__Instance);
            UiFontDescriptor managed;
            if (__TryGetNativeToManagedMapping(__Instance, out managed))
                __RecordNativeToManagedMapping(__Instance, null);

            __Instance = null;
        }

        public char8* Family
        {
            get
            {
                return (char8*) ((__Internal*)__Instance).Family;
            }

            set
            {
                ((__Internal*)__Instance).Family = (__IntPtr) value;
            }
        }

        public double Size
        {
            get
            {
                return ((__Internal*)__Instance).Size;
            }

            set
            {
                ((__Internal*)__Instance).Size = value;
            }
        }

        public uint32 Weight
        {
            get
            {
                return ((__Internal*)__Instance).Weight;
            }

            set
            {
                ((__Internal*)__Instance).Weight = value;
            }
        }

        public uint32 Italic
        {
            get
            {
                return ((__Internal*)__Instance).Italic;
            }

            set
            {
                ((__Internal*)__Instance).Italic = value;
            }
        }

        public uint32 Stretch
        {
            get
            {
                return ((__Internal*)__Instance).Stretch;
            }

            set
            {
                ((__Internal*)__Instance).Stretch = value;
            }
        }
    }

    public class UiDrawTextLayoutParams
    {
        [CRepr]
        public struct __Internal
        {
            internal __IntPtr String;
            internal __IntPtr DefaultFont;
            internal double Width;
            internal uint32 Align;

            [LinkName("??0uiDrawTextLayoutParams@@QEAA@AEBU0@@Z"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiDrawTextLayoutParams>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiDrawTextLayoutParams managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiDrawTextLayoutParams managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiDrawTextLayoutParams __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiDrawTextLayoutParams(native, skipVTables);
        }

        internal static UiDrawTextLayoutParams __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiDrawTextLayoutParams managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiDrawTextLayoutParams GetInstance(__IntPtr native)
        {
            UiDrawTextLayoutParams managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiDrawTextLayoutParams __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiDrawTextLayoutParams(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }

        public this()
        {
            __Instance = Internal.Malloc(sizeof(libui.UiDrawTextLayoutParams.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public this(libui.UiDrawTextLayoutParams _0)
        {
            __Instance = Internal.Malloc(sizeof(libui.UiDrawTextLayoutParams.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((libui.UiDrawTextLayoutParams.__Internal*) __Instance) = *((libui.UiDrawTextLayoutParams.__Internal*) _0.__Instance);
        }

        ~this()
        {
            if (__Instance == null)
                return;
            if (__ownsNativeInstance)
                Internal.Free(__Instance);
            UiDrawTextLayoutParams managed;
            if (__TryGetNativeToManagedMapping(__Instance, out managed))
                __RecordNativeToManagedMapping(__Instance, null);

            __Instance = null;
        }

        public libui.UiAttributedString String
        {
            get
            {
                var __result0 = libui.UiAttributedString.__GetOrCreateInstance(((__Internal*)__Instance).String, true);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance).String = value == null ? null : value.__Instance;
            }
        }

        public libui.UiFontDescriptor DefaultFont
        {
            get
            {
                var __result0 = libui.UiFontDescriptor.__GetOrCreateInstance(((__Internal*)__Instance).DefaultFont, true);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance).DefaultFont = value == null ? null : value.__Instance;
            }
        }

        public double Width
        {
            get
            {
                return ((__Internal*)__Instance).Width;
            }

            set
            {
                ((__Internal*)__Instance).Width = value;
            }
        }

        public uint32 Align
        {
            get
            {
                return ((__Internal*)__Instance).Align;
            }

            set
            {
                ((__Internal*)__Instance).Align = value;
            }
        }
    }

    public class UiAreaMouseEvent
    {
        [CRepr]
        public struct __Internal
        {
            internal double X;
            internal double Y;
            internal double AreaWidth;
            internal double AreaHeight;
            internal int32 Down;
            internal int32 Up;
            internal int32 Count;
            internal uint32 Modifiers;
            internal uint64 Held1To64;

            [LinkName("??0uiAreaMouseEvent@@QEAA@AEBU0@@Z"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiAreaMouseEvent>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiAreaMouseEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiAreaMouseEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiAreaMouseEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiAreaMouseEvent(native, skipVTables);
        }

        internal static UiAreaMouseEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiAreaMouseEvent managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiAreaMouseEvent GetInstance(__IntPtr native)
        {
            UiAreaMouseEvent managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiAreaMouseEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiAreaMouseEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }

        public this()
        {
            __Instance = Internal.Malloc(sizeof(libui.UiAreaMouseEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public this(libui.UiAreaMouseEvent _0)
        {
            __Instance = Internal.Malloc(sizeof(libui.UiAreaMouseEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((libui.UiAreaMouseEvent.__Internal*) __Instance) = *((libui.UiAreaMouseEvent.__Internal*) _0.__Instance);
        }

        ~this()
        {
            if (__Instance == null)
                return;
            if (__ownsNativeInstance)
                Internal.Free(__Instance);
            UiAreaMouseEvent managed;
            if (__TryGetNativeToManagedMapping(__Instance, out managed))
                __RecordNativeToManagedMapping(__Instance, null);

            __Instance = null;
        }

        public double X
        {
            get
            {
                return ((__Internal*)__Instance).X;
            }

            set
            {
                ((__Internal*)__Instance).X = value;
            }
        }

        public double Y
        {
            get
            {
                return ((__Internal*)__Instance).Y;
            }

            set
            {
                ((__Internal*)__Instance).Y = value;
            }
        }

        public double AreaWidth
        {
            get
            {
                return ((__Internal*)__Instance).AreaWidth;
            }

            set
            {
                ((__Internal*)__Instance).AreaWidth = value;
            }
        }

        public double AreaHeight
        {
            get
            {
                return ((__Internal*)__Instance).AreaHeight;
            }

            set
            {
                ((__Internal*)__Instance).AreaHeight = value;
            }
        }

        public int32 Down
        {
            get
            {
                return ((__Internal*)__Instance).Down;
            }

            set
            {
                ((__Internal*)__Instance).Down = value;
            }
        }

        public int32 Up
        {
            get
            {
                return ((__Internal*)__Instance).Up;
            }

            set
            {
                ((__Internal*)__Instance).Up = value;
            }
        }

        public int32 Count
        {
            get
            {
                return ((__Internal*)__Instance).Count;
            }

            set
            {
                ((__Internal*)__Instance).Count = value;
            }
        }

        public uint32 Modifiers
        {
            get
            {
                return ((__Internal*)__Instance).Modifiers;
            }

            set
            {
                ((__Internal*)__Instance).Modifiers = value;
            }
        }

        public uint64 Held1To64
        {
            get
            {
                return ((__Internal*)__Instance).Held1To64;
            }

            set
            {
                ((__Internal*)__Instance).Held1To64 = value;
            }
        }
    }

    public class UiAreaKeyEvent
    {
        [CRepr]
        public struct __Internal
        {
            internal int8 Key;
            internal uint32 ExtKey;
            internal uint32 Modifier;
            internal uint32 Modifiers;
            internal int32 Up;

            [LinkName("??0uiAreaKeyEvent@@QEAA@AEBU0@@Z"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiAreaKeyEvent>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiAreaKeyEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiAreaKeyEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiAreaKeyEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiAreaKeyEvent(native, skipVTables);
        }

        internal static UiAreaKeyEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiAreaKeyEvent managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiAreaKeyEvent GetInstance(__IntPtr native)
        {
            UiAreaKeyEvent managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiAreaKeyEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiAreaKeyEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }

        public this()
        {
            __Instance = Internal.Malloc(sizeof(libui.UiAreaKeyEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public this(libui.UiAreaKeyEvent _0)
        {
            __Instance = Internal.Malloc(sizeof(libui.UiAreaKeyEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((libui.UiAreaKeyEvent.__Internal*) __Instance) = *((libui.UiAreaKeyEvent.__Internal*) _0.__Instance);
        }

        ~this()
        {
            if (__Instance == null)
                return;
            if (__ownsNativeInstance)
                Internal.Free(__Instance);
            UiAreaKeyEvent managed;
            if (__TryGetNativeToManagedMapping(__Instance, out managed))
                __RecordNativeToManagedMapping(__Instance, null);

            __Instance = null;
        }

        public int8 Key
        {
            get
            {
                return ((__Internal*)__Instance).Key;
            }

            set
            {
                ((__Internal*)__Instance).Key = value;
            }
        }

        public uint32 ExtKey
        {
            get
            {
                return ((__Internal*)__Instance).ExtKey;
            }

            set
            {
                ((__Internal*)__Instance).ExtKey = value;
            }
        }

        public uint32 Modifier
        {
            get
            {
                return ((__Internal*)__Instance).Modifier;
            }

            set
            {
                ((__Internal*)__Instance).Modifier = value;
            }
        }

        public uint32 Modifiers
        {
            get
            {
                return ((__Internal*)__Instance).Modifiers;
            }

            set
            {
                ((__Internal*)__Instance).Modifiers = value;
            }
        }

        public int32 Up
        {
            get
            {
                return ((__Internal*)__Instance).Up;
            }

            set
            {
                ((__Internal*)__Instance).Up = value;
            }
        }
    }

    public class UiTableModelHandler
    {
        [CRepr]
        public struct __Internal
        {
            internal __IntPtr NumColumns;
            internal __IntPtr ColumnType;
            internal __IntPtr NumRows;
            internal __IntPtr CellValue;
            internal __IntPtr SetCellValue;

            [LinkName("??0uiTableModelHandler@@QEAA@AEBU0@@Z"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiTableModelHandler>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiTableModelHandler managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiTableModelHandler managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiTableModelHandler __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiTableModelHandler(native, skipVTables);
        }

        internal static UiTableModelHandler __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiTableModelHandler managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiTableModelHandler GetInstance(__IntPtr native)
        {
            UiTableModelHandler managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiTableModelHandler __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiTableModelHandler(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }

        public this()
        {
            __Instance = Internal.Malloc(sizeof(libui.UiTableModelHandler.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public this(libui.UiTableModelHandler _0)
        {
            __Instance = Internal.Malloc(sizeof(libui.UiTableModelHandler.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((libui.UiTableModelHandler.__Internal*) __Instance) = *((libui.UiTableModelHandler.__Internal*) _0.__Instance);
        }

        ~this()
        {
            if (__Instance == null)
                return;
            if (__ownsNativeInstance)
                Internal.Free(__Instance);
            UiTableModelHandler managed;
            if (__TryGetNativeToManagedMapping(__Instance, out managed))
                __RecordNativeToManagedMapping(__Instance, null);

            __Instance = null;
        }

        /// <summary>Returns the number of columns in the uiTableModel.</summary>
        /// <remarks>
        /// <para>This value MUST remain constant throughout the lifetime of the uiTableModel.</para>
        /// <para>This method is not guaranteed to be called depending on the system.</para>
        /// <para>strongly check column numbers and types on all platforms so</para>
        /// <para>these clauses can go away</para>
        /// </remarks>
        public libui.Delegates.Func_int___IntPtr___IntPtr NumColumns
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).NumColumns;
                return __ptr0 == null? null : *(libui.Delegates.Func_int___IntPtr___IntPtr*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).NumColumns = value == null ? null : value.GetFuncPtr();
            }
        }

        /// <summary>Returns the column type in for of a #uiTableValueType.</summary>
        /// <remarks>
        /// <para>This value MUST remain constant throughout the lifetime of the uiTableModel.</para>
        /// <para>This method is not guaranteed to be called depending on the system.</para>
        /// </remarks>
        public libui.Delegates.Func_uint32___IntPtr___IntPtr_int ColumnType
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).ColumnType;
                return __ptr0 == null? null : *(libui.Delegates.Func_uint32___IntPtr___IntPtr_int*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).ColumnType = value == null ? null : value.GetFuncPtr();
            }
        }

        /// <summary>Returns the number of rows in the uiTableModel.</summary>
        public libui.Delegates.Func_int___IntPtr___IntPtr NumRows
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).NumRows;
                return __ptr0 == null? null : *(libui.Delegates.Func_int___IntPtr___IntPtr*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).NumRows = value == null ? null : value.GetFuncPtr();
            }
        }

        /// <summary>Returns the cell value for (row, column).</summary>
        /// <remarks>
        /// <para>Make sure to use the uiTableValue constructors. The returned value</para>
        /// <para>must match the #uiTableValueType defined in ColumnType().</para>
        /// <para>Some columns may return `NULL` as a special value. Refer to the</para>
        /// <para>appropriate `uiTableAppend*Column()` documentation.</para>
        /// <para>uiTableValue objects are automatically freed when requested by</para>
        /// <para>a uiTable.</para>
        /// </remarks>
        public libui.Delegates.Func___IntPtr___IntPtr___IntPtr_int_int CellValue
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).CellValue;
                return __ptr0 == null? null : *(libui.Delegates.Func___IntPtr___IntPtr___IntPtr_int_int*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).CellValue = value == null ? null : value.GetFuncPtr();
            }
        }

        /// <summary>Sets the cell value for (row, column).</summary>
        /// <remarks>
        /// <para>It is up to the handler to decide what to do with the value: change</para>
        /// <para>the model or reject the change, keeping the old value.</para>
        /// <para>Some columns may call this function with `NULL` as a special value.</para>
        /// <para>Refer to the appropriate `uiTableAppend*Column()` documentation.</para>
        /// <para>uiTableValue objects are automatically freed upon return when</para>
        /// <para>set by a uiTable.</para>
        /// </remarks>
        public libui.Delegates.Action___IntPtr___IntPtr_int_int___IntPtr SetCellValue
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance).SetCellValue;
                return __ptr0 == null? null : *(libui.Delegates.Action___IntPtr___IntPtr_int_int___IntPtr*) &__ptr0;
            }

            set
            {
                ((__Internal*)__Instance).SetCellValue = value == null ? null : value.GetFuncPtr();
            }
        }
    }

    public class UiTableTextColumnOptionalParams
    {
        [CRepr]
        public struct __Internal
        {
            internal int32 ColorModelColumn;

            [LinkName("??0uiTableTextColumnOptionalParams@@QEAA@AEBU0@@Z"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiTableTextColumnOptionalParams>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiTableTextColumnOptionalParams managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiTableTextColumnOptionalParams managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiTableTextColumnOptionalParams __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiTableTextColumnOptionalParams(native, skipVTables);
        }

        internal static UiTableTextColumnOptionalParams __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiTableTextColumnOptionalParams managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiTableTextColumnOptionalParams GetInstance(__IntPtr native)
        {
            UiTableTextColumnOptionalParams managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiTableTextColumnOptionalParams __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiTableTextColumnOptionalParams(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }

        public this()
        {
            __Instance = Internal.Malloc(sizeof(libui.UiTableTextColumnOptionalParams.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public this(libui.UiTableTextColumnOptionalParams _0)
        {
            __Instance = Internal.Malloc(sizeof(libui.UiTableTextColumnOptionalParams.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((libui.UiTableTextColumnOptionalParams.__Internal*) __Instance) = *((libui.UiTableTextColumnOptionalParams.__Internal*) _0.__Instance);
        }

        ~this()
        {
            if (__Instance == null)
                return;
            if (__ownsNativeInstance)
                Internal.Free(__Instance);
            UiTableTextColumnOptionalParams managed;
            if (__TryGetNativeToManagedMapping(__Instance, out managed))
                __RecordNativeToManagedMapping(__Instance, null);

            __Instance = null;
        }

        /// <summary>uiTableModel column that defines the text color for each cell.</summary>
        /// <remarks>
        /// <para>#uiTableValueTypeColor Text color, `NULL` to use the default color</para>
        /// <para>for that cell.</para>
        /// <para>`-1` to use the default color for all cells.</para>
        /// </remarks>
        public int32 ColorModelColumn
        {
            get
            {
                return ((__Internal*)__Instance).ColorModelColumn;
            }

            set
            {
                ((__Internal*)__Instance).ColorModelColumn = value;
            }
        }
    }

    public class UiTableParams
    {
        [CRepr]
        public struct __Internal
        {
            internal __IntPtr Model;
            internal int32 RowBackgroundColorModelColumn;

            [LinkName("??0uiTableParams@@QEAA@AEBU0@@Z"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiTableParams>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiTableParams managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiTableParams managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiTableParams __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiTableParams(native, skipVTables);
        }

        internal static UiTableParams __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiTableParams managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiTableParams GetInstance(__IntPtr native)
        {
            UiTableParams managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiTableParams __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiTableParams(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }

        public this()
        {
            __Instance = Internal.Malloc(sizeof(libui.UiTableParams.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public this(libui.UiTableParams _0)
        {
            __Instance = Internal.Malloc(sizeof(libui.UiTableParams.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((libui.UiTableParams.__Internal*) __Instance) = *((libui.UiTableParams.__Internal*) _0.__Instance);
        }

        ~this()
        {
            if (__Instance == null)
                return;
            if (__ownsNativeInstance)
                Internal.Free(__Instance);
            UiTableParams managed;
            if (__TryGetNativeToManagedMapping(__Instance, out managed))
                __RecordNativeToManagedMapping(__Instance, null);

            __Instance = null;
        }

        /// <summary>Model holding the data to be displayed. This can NOT be `NULL`.</summary>
        public libui.UiTableModel Model
        {
            get
            {
                var __result0 = libui.UiTableModel.__GetOrCreateInstance(((__Internal*)__Instance).Model, true);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance).Model = value == null ? null : value.__Instance;
            }
        }

        /// <summary>uiTableModel column that defines background color for each row,</summary>
        /// <remarks>
        /// <para>#uiTableValueTypeColor Background color, `NULL` to use the default</para>
        /// <para>background color for that row.</para>
        /// <para>`-1` to use the default background color for all rows.</para>
        /// </remarks>
        public int32 RowBackgroundColorModelColumn
        {
            get
            {
                return ((__Internal*)__Instance).RowBackgroundColorModelColumn;
            }

            set
            {
                ((__Internal*)__Instance).RowBackgroundColorModelColumn = value;
            }
        }
    }

    public class UiTableSelection
    {
        [CRepr]
        public struct __Internal
        {
            internal int32 NumRows;
            internal __IntPtr Rows;

            [LinkName("??0uiTableSelection@@QEAA@AEBU0@@Z"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly var NativeToManagedMap =
            new System.Collections.Concurrent.ConcurrentDictionary<__IntPtr, libui.UiTableSelection>() ~ DeleteNativeToManagedMap!(_);

        private static mixin DeleteNativeToManagedMap(var container)
        {
        	if (container != null)
        	{
        		for (var value in container)
        		{
                    if (value.value != null)
        			    delete value.value;
        		}
        		delete container;
        	}
        }

        internal static void __RecordNativeToManagedMapping(__IntPtr native, libui.UiTableSelection managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(__IntPtr native, out libui.UiTableSelection managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UiTableSelection __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == null)
                return null;
            return new  UiTableSelection(native, skipVTables);
        }

        internal static UiTableSelection __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == null)
                return null;
            UiTableSelection managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        public static UiTableSelection GetInstance(__IntPtr native)
        {
            UiTableSelection managed;
            if (__TryGetNativeToManagedMapping(native, out managed))
                return managed;
            else
                return null;
        }

        internal static UiTableSelection __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UiTableSelection(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Internal.Malloc(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret;
        }

        private this(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected this(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = native;
        }

        public this()
        {
            __Instance = Internal.Malloc(sizeof(libui.UiTableSelection.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public this(libui.UiTableSelection _0)
        {
            __Instance = Internal.Malloc(sizeof(libui.UiTableSelection.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((libui.UiTableSelection.__Internal*) __Instance) = *((libui.UiTableSelection.__Internal*) _0.__Instance);
        }

        ~this()
        {
            if (__Instance == null)
                return;
            if (__ownsNativeInstance)
                Internal.Free(__Instance);
            UiTableSelection managed;
            if (__TryGetNativeToManagedMapping(__Instance, out managed))
                __RecordNativeToManagedMapping(__Instance, null);

            __Instance = null;
        }

        /// <summary>Number of selected rows.</summary>
        public int32 NumRows
        {
            get
            {
                return ((__Internal*)__Instance).NumRows;
            }

            set
            {
                ((__Internal*)__Instance).NumRows = value;
            }
        }

        /// <summary>Array containing selected row indices, NULL on empty selection.</summary>
        public int32* Rows
        {
            get
            {
                return (int32*) ((__Internal*)__Instance).Rows;
            }

            set
            {
                ((__Internal*)__Instance).Rows = (__IntPtr) value;
            }
        }
    }

    public class ui
    {
        public struct __Internal
        {
            [LinkName("uiInit"), CallingConvention(.Cdecl)]
            internal static extern char8* UiInit(__IntPtr options);

            [LinkName("uiUninit"), CallingConvention(.Cdecl)]
            internal static extern void UiUninit();

            [LinkName("uiFreeInitError"), CallingConvention(.Cdecl)]
            internal static extern void UiFreeInitError(char8* err);

            [LinkName("uiMain"), CallingConvention(.Cdecl)]
            internal static extern void UiMain();

            [LinkName("uiMainSteps"), CallingConvention(.Cdecl)]
            internal static extern void UiMainSteps();

            [LinkName("uiMainStep"), CallingConvention(.Cdecl)]
            internal static extern int32 UiMainStep(int32 wait);

            [LinkName("uiQuit"), CallingConvention(.Cdecl)]
            internal static extern void UiQuit();

            [LinkName("uiQueueMain"), CallingConvention(.Cdecl)]
            internal static extern void UiQueueMain(__IntPtr f, __IntPtr data);

            [LinkName("uiTimer"), CallingConvention(.Cdecl)]
            internal static extern void UiTimer(int32 milliseconds, __IntPtr f, __IntPtr data);

            [LinkName("uiOnShouldQuit"), CallingConvention(.Cdecl)]
            internal static extern void UiOnShouldQuit(__IntPtr f, __IntPtr data);

            [LinkName("uiFreeText"), CallingConvention(.Cdecl)]
            internal static extern void UiFreeText(char8* text);

            [LinkName("uiControlDestroy"), CallingConvention(.Cdecl)]
            internal static extern void UiControlDestroy(__IntPtr c);

            [LinkName("uiControlHandle"), CallingConvention(.Cdecl)]
            internal static extern uint64 UiControlHandle(__IntPtr c);

            [LinkName("uiControlParent"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiControlParent(__IntPtr c);

            [LinkName("uiControlSetParent"), CallingConvention(.Cdecl)]
            internal static extern void UiControlSetParent(__IntPtr c, __IntPtr parent);

            [LinkName("uiControlToplevel"), CallingConvention(.Cdecl)]
            internal static extern int32 UiControlToplevel(__IntPtr c);

            [LinkName("uiControlVisible"), CallingConvention(.Cdecl)]
            internal static extern int32 UiControlVisible(__IntPtr c);

            [LinkName("uiControlShow"), CallingConvention(.Cdecl)]
            internal static extern void UiControlShow(__IntPtr c);

            [LinkName("uiControlHide"), CallingConvention(.Cdecl)]
            internal static extern void UiControlHide(__IntPtr c);

            [LinkName("uiControlEnabled"), CallingConvention(.Cdecl)]
            internal static extern int32 UiControlEnabled(__IntPtr c);

            [LinkName("uiControlEnable"), CallingConvention(.Cdecl)]
            internal static extern void UiControlEnable(__IntPtr c);

            [LinkName("uiControlDisable"), CallingConvention(.Cdecl)]
            internal static extern void UiControlDisable(__IntPtr c);

            [LinkName("uiAllocControl"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiAllocControl(uint64 n, uint32 OSsig, uint32 typesig, char8* typenamestr);

            [LinkName("uiFreeControl"), CallingConvention(.Cdecl)]
            internal static extern void UiFreeControl(__IntPtr c);

            [LinkName("uiControlVerifySetParent"), CallingConvention(.Cdecl)]
            internal static extern void UiControlVerifySetParent(__IntPtr c, __IntPtr parent);

            [LinkName("uiControlEnabledToUser"), CallingConvention(.Cdecl)]
            internal static extern int32 UiControlEnabledToUser(__IntPtr c);

            [LinkName("uiUserBugCannotSetParentOnToplevel"), CallingConvention(.Cdecl)]
            internal static extern void UiUserBugCannotSetParentOnToplevel(char8* type);

            [LinkName("uiWindowTitle"), CallingConvention(.Cdecl)]
            internal static extern char8* UiWindowTitle(__IntPtr w);

            [LinkName("uiWindowSetTitle"), CallingConvention(.Cdecl)]
            internal static extern void UiWindowSetTitle(__IntPtr w, char8* title);

            [LinkName("uiWindowPosition"), CallingConvention(.Cdecl)]
            internal static extern void UiWindowPosition(__IntPtr w, int32* x, int32* y);

            [LinkName("uiWindowSetPosition"), CallingConvention(.Cdecl)]
            internal static extern void UiWindowSetPosition(__IntPtr w, int32 x, int32 y);

            [LinkName("uiWindowOnPositionChanged"), CallingConvention(.Cdecl)]
            internal static extern void UiWindowOnPositionChanged(__IntPtr w, __IntPtr f, __IntPtr data);

            [LinkName("uiWindowContentSize"), CallingConvention(.Cdecl)]
            internal static extern void UiWindowContentSize(__IntPtr w, int32* width, int32* height);

            [LinkName("uiWindowSetContentSize"), CallingConvention(.Cdecl)]
            internal static extern void UiWindowSetContentSize(__IntPtr w, int32 width, int32 height);

            [LinkName("uiWindowFullscreen"), CallingConvention(.Cdecl)]
            internal static extern int32 UiWindowFullscreen(__IntPtr w);

            [LinkName("uiWindowSetFullscreen"), CallingConvention(.Cdecl)]
            internal static extern void UiWindowSetFullscreen(__IntPtr w, int32 fullscreen);

            [LinkName("uiWindowOnContentSizeChanged"), CallingConvention(.Cdecl)]
            internal static extern void UiWindowOnContentSizeChanged(__IntPtr w, __IntPtr f, __IntPtr data);

            [LinkName("uiWindowOnClosing"), CallingConvention(.Cdecl)]
            internal static extern void UiWindowOnClosing(__IntPtr w, __IntPtr f, __IntPtr data);

            [LinkName("uiWindowOnFocusChanged"), CallingConvention(.Cdecl)]
            internal static extern void UiWindowOnFocusChanged(__IntPtr w, __IntPtr f, __IntPtr data);

            [LinkName("uiWindowFocused"), CallingConvention(.Cdecl)]
            internal static extern int32 UiWindowFocused(__IntPtr w);

            [LinkName("uiWindowBorderless"), CallingConvention(.Cdecl)]
            internal static extern int32 UiWindowBorderless(__IntPtr w);

            [LinkName("uiWindowSetBorderless"), CallingConvention(.Cdecl)]
            internal static extern void UiWindowSetBorderless(__IntPtr w, int32 borderless);

            [LinkName("uiWindowSetChild"), CallingConvention(.Cdecl)]
            internal static extern void UiWindowSetChild(__IntPtr w, __IntPtr child);

            [LinkName("uiWindowMargined"), CallingConvention(.Cdecl)]
            internal static extern int32 UiWindowMargined(__IntPtr w);

            [LinkName("uiWindowSetMargined"), CallingConvention(.Cdecl)]
            internal static extern void UiWindowSetMargined(__IntPtr w, int32 margined);

            [LinkName("uiWindowResizeable"), CallingConvention(.Cdecl)]
            internal static extern int32 UiWindowResizeable(__IntPtr w);

            [LinkName("uiWindowSetResizeable"), CallingConvention(.Cdecl)]
            internal static extern void UiWindowSetResizeable(__IntPtr w, int32 resizeable);

            [LinkName("uiNewWindow"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewWindow(char8* title, int32 width, int32 height, int32 hasMenubar);

            [LinkName("uiButtonText"), CallingConvention(.Cdecl)]
            internal static extern char8* UiButtonText(__IntPtr b);

            [LinkName("uiButtonSetText"), CallingConvention(.Cdecl)]
            internal static extern void UiButtonSetText(__IntPtr b, char8* text);

            [LinkName("uiButtonOnClicked"), CallingConvention(.Cdecl)]
            internal static extern void UiButtonOnClicked(__IntPtr b, __IntPtr f, __IntPtr data);

            [LinkName("uiNewButton"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewButton(char8* text);

            [LinkName("uiBoxAppend"), CallingConvention(.Cdecl)]
            internal static extern void UiBoxAppend(__IntPtr b, __IntPtr child, int32 stretchy);

            [LinkName("uiBoxNumChildren"), CallingConvention(.Cdecl)]
            internal static extern int32 UiBoxNumChildren(__IntPtr b);

            [LinkName("uiBoxDelete"), CallingConvention(.Cdecl)]
            internal static extern void UiBoxDelete(__IntPtr b, int32 index);

            [LinkName("uiBoxPadded"), CallingConvention(.Cdecl)]
            internal static extern int32 UiBoxPadded(__IntPtr b);

            [LinkName("uiBoxSetPadded"), CallingConvention(.Cdecl)]
            internal static extern void UiBoxSetPadded(__IntPtr b, int32 padded);

            [LinkName("uiNewHorizontalBox"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewHorizontalBox();

            [LinkName("uiNewVerticalBox"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewVerticalBox();

            [LinkName("uiCheckboxText"), CallingConvention(.Cdecl)]
            internal static extern char8* UiCheckboxText(__IntPtr c);

            [LinkName("uiCheckboxSetText"), CallingConvention(.Cdecl)]
            internal static extern void UiCheckboxSetText(__IntPtr c, char8* text);

            [LinkName("uiCheckboxOnToggled"), CallingConvention(.Cdecl)]
            internal static extern void UiCheckboxOnToggled(__IntPtr c, __IntPtr f, __IntPtr data);

            [LinkName("uiCheckboxChecked"), CallingConvention(.Cdecl)]
            internal static extern int32 UiCheckboxChecked(__IntPtr c);

            [LinkName("uiCheckboxSetChecked"), CallingConvention(.Cdecl)]
            internal static extern void UiCheckboxSetChecked(__IntPtr c, int32 _checked);

            [LinkName("uiNewCheckbox"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewCheckbox(char8* text);

            [LinkName("uiEntryText"), CallingConvention(.Cdecl)]
            internal static extern char8* UiEntryText(__IntPtr e);

            [LinkName("uiEntrySetText"), CallingConvention(.Cdecl)]
            internal static extern void UiEntrySetText(__IntPtr e, char8* text);

            [LinkName("uiEntryOnChanged"), CallingConvention(.Cdecl)]
            internal static extern void UiEntryOnChanged(__IntPtr e, __IntPtr f, __IntPtr data);

            [LinkName("uiEntryReadOnly"), CallingConvention(.Cdecl)]
            internal static extern int32 UiEntryReadOnly(__IntPtr e);

            [LinkName("uiEntrySetReadOnly"), CallingConvention(.Cdecl)]
            internal static extern void UiEntrySetReadOnly(__IntPtr e, int32 _readonly);

            [LinkName("uiNewEntry"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewEntry();

            [LinkName("uiNewPasswordEntry"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewPasswordEntry();

            [LinkName("uiNewSearchEntry"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewSearchEntry();

            [LinkName("uiLabelText"), CallingConvention(.Cdecl)]
            internal static extern char8* UiLabelText(__IntPtr l);

            [LinkName("uiLabelSetText"), CallingConvention(.Cdecl)]
            internal static extern void UiLabelSetText(__IntPtr l, char8* text);

            [LinkName("uiNewLabel"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewLabel(char8* text);

            [LinkName("uiTabSelected"), CallingConvention(.Cdecl)]
            internal static extern int32 UiTabSelected(__IntPtr t);

            [LinkName("uiTabSetSelected"), CallingConvention(.Cdecl)]
            internal static extern void UiTabSetSelected(__IntPtr t, int32 index);

            [LinkName("uiTabOnSelected"), CallingConvention(.Cdecl)]
            internal static extern void UiTabOnSelected(__IntPtr t, __IntPtr f, __IntPtr data);

            [LinkName("uiTabAppend"), CallingConvention(.Cdecl)]
            internal static extern void UiTabAppend(__IntPtr t, char8* name, __IntPtr c);

            [LinkName("uiTabInsertAt"), CallingConvention(.Cdecl)]
            internal static extern void UiTabInsertAt(__IntPtr t, char8* name, int32 index, __IntPtr c);

            [LinkName("uiTabDelete"), CallingConvention(.Cdecl)]
            internal static extern void UiTabDelete(__IntPtr t, int32 index);

            [LinkName("uiTabNumPages"), CallingConvention(.Cdecl)]
            internal static extern int32 UiTabNumPages(__IntPtr t);

            [LinkName("uiTabMargined"), CallingConvention(.Cdecl)]
            internal static extern int32 UiTabMargined(__IntPtr t, int32 index);

            [LinkName("uiTabSetMargined"), CallingConvention(.Cdecl)]
            internal static extern void UiTabSetMargined(__IntPtr t, int32 index, int32 margined);

            [LinkName("uiNewTab"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewTab();

            [LinkName("uiGroupTitle"), CallingConvention(.Cdecl)]
            internal static extern char8* UiGroupTitle(__IntPtr g);

            [LinkName("uiGroupSetTitle"), CallingConvention(.Cdecl)]
            internal static extern void UiGroupSetTitle(__IntPtr g, char8* title);

            [LinkName("uiGroupSetChild"), CallingConvention(.Cdecl)]
            internal static extern void UiGroupSetChild(__IntPtr g, __IntPtr c);

            [LinkName("uiGroupMargined"), CallingConvention(.Cdecl)]
            internal static extern int32 UiGroupMargined(__IntPtr g);

            [LinkName("uiGroupSetMargined"), CallingConvention(.Cdecl)]
            internal static extern void UiGroupSetMargined(__IntPtr g, int32 margined);

            [LinkName("uiNewGroup"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewGroup(char8* title);

            [LinkName("uiSpinboxValue"), CallingConvention(.Cdecl)]
            internal static extern int32 UiSpinboxValue(__IntPtr s);

            [LinkName("uiSpinboxSetValue"), CallingConvention(.Cdecl)]
            internal static extern void UiSpinboxSetValue(__IntPtr s, int32 value);

            [LinkName("uiSpinboxOnChanged"), CallingConvention(.Cdecl)]
            internal static extern void UiSpinboxOnChanged(__IntPtr s, __IntPtr f, __IntPtr data);

            [LinkName("uiNewSpinbox"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewSpinbox(int32 min, int32 max);

            [LinkName("uiSliderValue"), CallingConvention(.Cdecl)]
            internal static extern int32 UiSliderValue(__IntPtr s);

            [LinkName("uiSliderSetValue"), CallingConvention(.Cdecl)]
            internal static extern void UiSliderSetValue(__IntPtr s, int32 value);

            [LinkName("uiSliderHasToolTip"), CallingConvention(.Cdecl)]
            internal static extern int32 UiSliderHasToolTip(__IntPtr s);

            [LinkName("uiSliderSetHasToolTip"), CallingConvention(.Cdecl)]
            internal static extern void UiSliderSetHasToolTip(__IntPtr s, int32 hasToolTip);

            [LinkName("uiSliderOnChanged"), CallingConvention(.Cdecl)]
            internal static extern void UiSliderOnChanged(__IntPtr s, __IntPtr f, __IntPtr data);

            [LinkName("uiSliderOnReleased"), CallingConvention(.Cdecl)]
            internal static extern void UiSliderOnReleased(__IntPtr s, __IntPtr f, __IntPtr data);

            [LinkName("uiSliderSetRange"), CallingConvention(.Cdecl)]
            internal static extern void UiSliderSetRange(__IntPtr s, int32 min, int32 max);

            [LinkName("uiNewSlider"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewSlider(int32 min, int32 max);

            [LinkName("uiProgressBarValue"), CallingConvention(.Cdecl)]
            internal static extern int32 UiProgressBarValue(__IntPtr p);

            [LinkName("uiProgressBarSetValue"), CallingConvention(.Cdecl)]
            internal static extern void UiProgressBarSetValue(__IntPtr p, int32 n);

            [LinkName("uiNewProgressBar"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewProgressBar();

            [LinkName("uiNewHorizontalSeparator"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewHorizontalSeparator();

            [LinkName("uiNewVerticalSeparator"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewVerticalSeparator();

            [LinkName("uiComboboxAppend"), CallingConvention(.Cdecl)]
            internal static extern void UiComboboxAppend(__IntPtr c, char8* text);

            [LinkName("uiComboboxInsertAt"), CallingConvention(.Cdecl)]
            internal static extern void UiComboboxInsertAt(__IntPtr c, int32 index, char8* text);

            [LinkName("uiComboboxDelete"), CallingConvention(.Cdecl)]
            internal static extern void UiComboboxDelete(__IntPtr c, int32 index);

            [LinkName("uiComboboxClear"), CallingConvention(.Cdecl)]
            internal static extern void UiComboboxClear(__IntPtr c);

            [LinkName("uiComboboxNumItems"), CallingConvention(.Cdecl)]
            internal static extern int32 UiComboboxNumItems(__IntPtr c);

            [LinkName("uiComboboxSelected"), CallingConvention(.Cdecl)]
            internal static extern int32 UiComboboxSelected(__IntPtr c);

            [LinkName("uiComboboxSetSelected"), CallingConvention(.Cdecl)]
            internal static extern void UiComboboxSetSelected(__IntPtr c, int32 index);

            [LinkName("uiComboboxOnSelected"), CallingConvention(.Cdecl)]
            internal static extern void UiComboboxOnSelected(__IntPtr c, __IntPtr f, __IntPtr data);

            [LinkName("uiNewCombobox"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewCombobox();

            [LinkName("uiEditableComboboxAppend"), CallingConvention(.Cdecl)]
            internal static extern void UiEditableComboboxAppend(__IntPtr c, char8* text);

            [LinkName("uiEditableComboboxText"), CallingConvention(.Cdecl)]
            internal static extern char8* UiEditableComboboxText(__IntPtr c);

            [LinkName("uiEditableComboboxSetText"), CallingConvention(.Cdecl)]
            internal static extern void UiEditableComboboxSetText(__IntPtr c, char8* text);

            [LinkName("uiEditableComboboxOnChanged"), CallingConvention(.Cdecl)]
            internal static extern void UiEditableComboboxOnChanged(__IntPtr c, __IntPtr f, __IntPtr data);

            [LinkName("uiNewEditableCombobox"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewEditableCombobox();

            [LinkName("uiRadioButtonsAppend"), CallingConvention(.Cdecl)]
            internal static extern void UiRadioButtonsAppend(__IntPtr r, char8* text);

            [LinkName("uiRadioButtonsSelected"), CallingConvention(.Cdecl)]
            internal static extern int32 UiRadioButtonsSelected(__IntPtr r);

            [LinkName("uiRadioButtonsSetSelected"), CallingConvention(.Cdecl)]
            internal static extern void UiRadioButtonsSetSelected(__IntPtr r, int32 index);

            [LinkName("uiRadioButtonsOnSelected"), CallingConvention(.Cdecl)]
            internal static extern void UiRadioButtonsOnSelected(__IntPtr r, __IntPtr f, __IntPtr data);

            [LinkName("uiNewRadioButtons"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewRadioButtons();

            [LinkName("uiDateTimePickerTime"), CallingConvention(.Cdecl)]
            internal static extern void UiDateTimePickerTime(__IntPtr d, __IntPtr time);

            [LinkName("uiDateTimePickerSetTime"), CallingConvention(.Cdecl)]
            internal static extern void UiDateTimePickerSetTime(__IntPtr d, __IntPtr time);

            [LinkName("uiDateTimePickerOnChanged"), CallingConvention(.Cdecl)]
            internal static extern void UiDateTimePickerOnChanged(__IntPtr d, __IntPtr f, __IntPtr data);

            [LinkName("uiNewDateTimePicker"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewDateTimePicker();

            [LinkName("uiNewDatePicker"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewDatePicker();

            [LinkName("uiNewTimePicker"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewTimePicker();

            [LinkName("uiMultilineEntryText"), CallingConvention(.Cdecl)]
            internal static extern char8* UiMultilineEntryText(__IntPtr e);

            [LinkName("uiMultilineEntrySetText"), CallingConvention(.Cdecl)]
            internal static extern void UiMultilineEntrySetText(__IntPtr e, char8* text);

            [LinkName("uiMultilineEntryAppend"), CallingConvention(.Cdecl)]
            internal static extern void UiMultilineEntryAppend(__IntPtr e, char8* text);

            [LinkName("uiMultilineEntryOnChanged"), CallingConvention(.Cdecl)]
            internal static extern void UiMultilineEntryOnChanged(__IntPtr e, __IntPtr f, __IntPtr data);

            [LinkName("uiMultilineEntryReadOnly"), CallingConvention(.Cdecl)]
            internal static extern int32 UiMultilineEntryReadOnly(__IntPtr e);

            [LinkName("uiMultilineEntrySetReadOnly"), CallingConvention(.Cdecl)]
            internal static extern void UiMultilineEntrySetReadOnly(__IntPtr e, int32 _readonly);

            [LinkName("uiNewMultilineEntry"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewMultilineEntry();

            [LinkName("uiNewNonWrappingMultilineEntry"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewNonWrappingMultilineEntry();

            [LinkName("uiMenuItemEnable"), CallingConvention(.Cdecl)]
            internal static extern void UiMenuItemEnable(__IntPtr m);

            [LinkName("uiMenuItemDisable"), CallingConvention(.Cdecl)]
            internal static extern void UiMenuItemDisable(__IntPtr m);

            [LinkName("uiMenuItemOnClicked"), CallingConvention(.Cdecl)]
            internal static extern void UiMenuItemOnClicked(__IntPtr m, __IntPtr f, __IntPtr data);

            [LinkName("uiMenuItemChecked"), CallingConvention(.Cdecl)]
            internal static extern int32 UiMenuItemChecked(__IntPtr m);

            [LinkName("uiMenuItemSetChecked"), CallingConvention(.Cdecl)]
            internal static extern void UiMenuItemSetChecked(__IntPtr m, int32 _checked);

            [LinkName("uiMenuAppendItem"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiMenuAppendItem(__IntPtr m, char8* name);

            [LinkName("uiMenuAppendCheckItem"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiMenuAppendCheckItem(__IntPtr m, char8* name);

            [LinkName("uiMenuAppendQuitItem"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiMenuAppendQuitItem(__IntPtr m);

            [LinkName("uiMenuAppendPreferencesItem"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiMenuAppendPreferencesItem(__IntPtr m);

            [LinkName("uiMenuAppendAboutItem"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiMenuAppendAboutItem(__IntPtr m);

            [LinkName("uiMenuAppendSeparator"), CallingConvention(.Cdecl)]
            internal static extern void UiMenuAppendSeparator(__IntPtr m);

            [LinkName("uiNewMenu"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewMenu(char8* name);

            [LinkName("uiOpenFile"), CallingConvention(.Cdecl)]
            internal static extern char8* UiOpenFile(__IntPtr parent);

            [LinkName("uiOpenFolder"), CallingConvention(.Cdecl)]
            internal static extern char8* UiOpenFolder(__IntPtr parent);

            [LinkName("uiSaveFile"), CallingConvention(.Cdecl)]
            internal static extern char8* UiSaveFile(__IntPtr parent);

            [LinkName("uiMsgBox"), CallingConvention(.Cdecl)]
            internal static extern void UiMsgBox(__IntPtr parent, char8* title, char8* description);

            [LinkName("uiMsgBoxError"), CallingConvention(.Cdecl)]
            internal static extern void UiMsgBoxError(__IntPtr parent, char8* title, char8* description);

            [LinkName("uiAreaSetSize"), CallingConvention(.Cdecl)]
            internal static extern void UiAreaSetSize(__IntPtr a, int32 width, int32 height);

            [LinkName("uiAreaQueueRedrawAll"), CallingConvention(.Cdecl)]
            internal static extern void UiAreaQueueRedrawAll(__IntPtr a);

            [LinkName("uiAreaScrollTo"), CallingConvention(.Cdecl)]
            internal static extern void UiAreaScrollTo(__IntPtr a, double x, double y, double width, double height);

            [LinkName("uiAreaBeginUserWindowMove"), CallingConvention(.Cdecl)]
            internal static extern void UiAreaBeginUserWindowMove(__IntPtr a);

            [LinkName("uiAreaBeginUserWindowResize"), CallingConvention(.Cdecl)]
            internal static extern void UiAreaBeginUserWindowResize(__IntPtr a, uint32 edge);

            [LinkName("uiNewArea"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewArea(__IntPtr ah);

            [LinkName("uiNewScrollingArea"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewScrollingArea(__IntPtr ah, int32 width, int32 height);

            [LinkName("uiDrawNewPath"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiDrawNewPath(uint32 fillMode);

            [LinkName("uiDrawFreePath"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawFreePath(__IntPtr p);

            [LinkName("uiDrawPathNewFigure"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawPathNewFigure(__IntPtr p, double x, double y);

            [LinkName("uiDrawPathNewFigureWithArc"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawPathNewFigureWithArc(__IntPtr p, double xCenter, double yCenter, double radius, double startAngle, double sweep, int32 negative);

            [LinkName("uiDrawPathLineTo"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawPathLineTo(__IntPtr p, double x, double y);

            [LinkName("uiDrawPathArcTo"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawPathArcTo(__IntPtr p, double xCenter, double yCenter, double radius, double startAngle, double sweep, int32 negative);

            [LinkName("uiDrawPathBezierTo"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawPathBezierTo(__IntPtr p, double c1x, double c1y, double c2x, double c2y, double endX, double endY);

            [LinkName("uiDrawPathCloseFigure"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawPathCloseFigure(__IntPtr p);

            [LinkName("uiDrawPathAddRectangle"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawPathAddRectangle(__IntPtr p, double x, double y, double width, double height);

            [LinkName("uiDrawPathEnded"), CallingConvention(.Cdecl)]
            internal static extern int32 UiDrawPathEnded(__IntPtr p);

            [LinkName("uiDrawPathEnd"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawPathEnd(__IntPtr p);

            [LinkName("uiDrawStroke"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawStroke(__IntPtr c, __IntPtr path, __IntPtr b, __IntPtr p);

            [LinkName("uiDrawFill"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawFill(__IntPtr c, __IntPtr path, __IntPtr b);

            [LinkName("uiDrawMatrixSetIdentity"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawMatrixSetIdentity(__IntPtr m);

            [LinkName("uiDrawMatrixTranslate"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawMatrixTranslate(__IntPtr m, double x, double y);

            [LinkName("uiDrawMatrixScale"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawMatrixScale(__IntPtr m, double xCenter, double yCenter, double x, double y);

            [LinkName("uiDrawMatrixRotate"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawMatrixRotate(__IntPtr m, double x, double y, double amount);

            [LinkName("uiDrawMatrixSkew"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawMatrixSkew(__IntPtr m, double x, double y, double xamount, double yamount);

            [LinkName("uiDrawMatrixMultiply"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawMatrixMultiply(__IntPtr dest, __IntPtr src);

            [LinkName("uiDrawMatrixInvertible"), CallingConvention(.Cdecl)]
            internal static extern int32 UiDrawMatrixInvertible(__IntPtr m);

            [LinkName("uiDrawMatrixInvert"), CallingConvention(.Cdecl)]
            internal static extern int32 UiDrawMatrixInvert(__IntPtr m);

            [LinkName("uiDrawMatrixTransformPoint"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawMatrixTransformPoint(__IntPtr m, double* x, double* y);

            [LinkName("uiDrawMatrixTransformSize"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawMatrixTransformSize(__IntPtr m, double* x, double* y);

            [LinkName("uiDrawTransform"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawTransform(__IntPtr c, __IntPtr m);

            [LinkName("uiDrawClip"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawClip(__IntPtr c, __IntPtr path);

            [LinkName("uiDrawSave"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawSave(__IntPtr c);

            [LinkName("uiDrawRestore"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawRestore(__IntPtr c);

            [LinkName("uiFreeAttribute"), CallingConvention(.Cdecl)]
            internal static extern void UiFreeAttribute(__IntPtr a);

            [LinkName("uiAttributeGetType"), CallingConvention(.Cdecl)]
            internal static extern uint32 UiAttributeGetType(__IntPtr a);

            [LinkName("uiNewFamilyAttribute"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewFamilyAttribute(char8* family);

            [LinkName("uiAttributeFamily"), CallingConvention(.Cdecl)]
            internal static extern char8* UiAttributeFamily(__IntPtr a);

            [LinkName("uiNewSizeAttribute"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewSizeAttribute(double size);

            [LinkName("uiAttributeSize"), CallingConvention(.Cdecl)]
            internal static extern double UiAttributeSize(__IntPtr a);

            [LinkName("uiNewWeightAttribute"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewWeightAttribute(uint32 weight);

            [LinkName("uiAttributeWeight"), CallingConvention(.Cdecl)]
            internal static extern uint32 UiAttributeWeight(__IntPtr a);

            [LinkName("uiNewItalicAttribute"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewItalicAttribute(uint32 italic);

            [LinkName("uiAttributeItalic"), CallingConvention(.Cdecl)]
            internal static extern uint32 UiAttributeItalic(__IntPtr a);

            [LinkName("uiNewStretchAttribute"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewStretchAttribute(uint32 stretch);

            [LinkName("uiAttributeStretch"), CallingConvention(.Cdecl)]
            internal static extern uint32 UiAttributeStretch(__IntPtr a);

            [LinkName("uiNewColorAttribute"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewColorAttribute(double r, double g, double b, double a);

            [LinkName("uiAttributeColor"), CallingConvention(.Cdecl)]
            internal static extern void UiAttributeColor(__IntPtr a, double* r, double* g, double* b, double* alpha);

            [LinkName("uiNewBackgroundAttribute"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewBackgroundAttribute(double r, double g, double b, double a);

            [LinkName("uiNewUnderlineAttribute"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewUnderlineAttribute(uint32 u);

            [LinkName("uiAttributeUnderline"), CallingConvention(.Cdecl)]
            internal static extern uint32 UiAttributeUnderline(__IntPtr a);

            [LinkName("uiNewUnderlineColorAttribute"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewUnderlineColorAttribute(uint32 u, double r, double g, double b, double a);

            [LinkName("uiAttributeUnderlineColor"), CallingConvention(.Cdecl)]
            internal static extern void UiAttributeUnderlineColor(__IntPtr a, uint32* u, double* r, double* g, double* b, double* alpha);

            [LinkName("uiNewOpenTypeFeatures"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewOpenTypeFeatures();

            [LinkName("uiFreeOpenTypeFeatures"), CallingConvention(.Cdecl)]
            internal static extern void UiFreeOpenTypeFeatures(__IntPtr otf);

            [LinkName("uiOpenTypeFeaturesClone"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiOpenTypeFeaturesClone(__IntPtr otf);

            [LinkName("uiOpenTypeFeaturesAdd"), CallingConvention(.Cdecl)]
            internal static extern void UiOpenTypeFeaturesAdd(__IntPtr otf, int8 a, int8 b, int8 c, int8 d, uint32 value);

            [LinkName("uiOpenTypeFeaturesRemove"), CallingConvention(.Cdecl)]
            internal static extern void UiOpenTypeFeaturesRemove(__IntPtr otf, int8 a, int8 b, int8 c, int8 d);

            [LinkName("uiOpenTypeFeaturesGet"), CallingConvention(.Cdecl)]
            internal static extern int32 UiOpenTypeFeaturesGet(__IntPtr otf, int8 a, int8 b, int8 c, int8 d, uint32* value);

            [LinkName("uiOpenTypeFeaturesForEach"), CallingConvention(.Cdecl)]
            internal static extern void UiOpenTypeFeaturesForEach(__IntPtr otf, __IntPtr f, __IntPtr data);

            [LinkName("uiNewFeaturesAttribute"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewFeaturesAttribute(__IntPtr otf);

            [LinkName("uiAttributeFeatures"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiAttributeFeatures(__IntPtr a);

            [LinkName("uiNewAttributedString"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewAttributedString(char8* initialString);

            [LinkName("uiFreeAttributedString"), CallingConvention(.Cdecl)]
            internal static extern void UiFreeAttributedString(__IntPtr s);

            [LinkName("uiAttributedStringString"), CallingConvention(.Cdecl)]
            internal static extern char8* UiAttributedStringString(__IntPtr s);

            [LinkName("uiAttributedStringLen"), CallingConvention(.Cdecl)]
            internal static extern uint64 UiAttributedStringLen(__IntPtr s);

            [LinkName("uiAttributedStringAppendUnattributed"), CallingConvention(.Cdecl)]
            internal static extern void UiAttributedStringAppendUnattributed(__IntPtr s, char8* str);

            [LinkName("uiAttributedStringInsertAtUnattributed"), CallingConvention(.Cdecl)]
            internal static extern void UiAttributedStringInsertAtUnattributed(__IntPtr s, char8* str, uint64 at);

            [LinkName("uiAttributedStringDelete"), CallingConvention(.Cdecl)]
            internal static extern void UiAttributedStringDelete(__IntPtr s, uint64 start, uint64 end);

            [LinkName("uiAttributedStringSetAttribute"), CallingConvention(.Cdecl)]
            internal static extern void UiAttributedStringSetAttribute(__IntPtr s, __IntPtr a, uint64 start, uint64 end);

            [LinkName("uiAttributedStringForEachAttribute"), CallingConvention(.Cdecl)]
            internal static extern void UiAttributedStringForEachAttribute(__IntPtr s, __IntPtr f, __IntPtr data);

            [LinkName("uiAttributedStringNumGraphemes"), CallingConvention(.Cdecl)]
            internal static extern uint64 UiAttributedStringNumGraphemes(__IntPtr s);

            [LinkName("uiAttributedStringByteIndexToGrapheme"), CallingConvention(.Cdecl)]
            internal static extern uint64 UiAttributedStringByteIndexToGrapheme(__IntPtr s, uint64 pos);

            [LinkName("uiAttributedStringGraphemeToByteIndex"), CallingConvention(.Cdecl)]
            internal static extern uint64 UiAttributedStringGraphemeToByteIndex(__IntPtr s, uint64 pos);

            [LinkName("uiLoadControlFont"), CallingConvention(.Cdecl)]
            internal static extern void UiLoadControlFont(__IntPtr f);

            [LinkName("uiFreeFontDescriptor"), CallingConvention(.Cdecl)]
            internal static extern void UiFreeFontDescriptor(__IntPtr desc);

            [LinkName("uiDrawNewTextLayout"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiDrawNewTextLayout(__IntPtr _params);

            [LinkName("uiDrawFreeTextLayout"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawFreeTextLayout(__IntPtr tl);

            [LinkName("uiDrawText"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawText(__IntPtr c, __IntPtr tl, double x, double y);

            [LinkName("uiDrawTextLayoutExtents"), CallingConvention(.Cdecl)]
            internal static extern void UiDrawTextLayoutExtents(__IntPtr tl, double* width, double* height);

            [LinkName("uiFontButtonFont"), CallingConvention(.Cdecl)]
            internal static extern void UiFontButtonFont(__IntPtr b, __IntPtr desc);

            [LinkName("uiFontButtonOnChanged"), CallingConvention(.Cdecl)]
            internal static extern void UiFontButtonOnChanged(__IntPtr b, __IntPtr f, __IntPtr data);

            [LinkName("uiNewFontButton"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewFontButton();

            [LinkName("uiFreeFontButtonFont"), CallingConvention(.Cdecl)]
            internal static extern void UiFreeFontButtonFont(__IntPtr desc);

            [LinkName("uiColorButtonColor"), CallingConvention(.Cdecl)]
            internal static extern void UiColorButtonColor(__IntPtr b, double* r, double* g, double* bl, double* a);

            [LinkName("uiColorButtonSetColor"), CallingConvention(.Cdecl)]
            internal static extern void UiColorButtonSetColor(__IntPtr b, double r, double g, double bl, double a);

            [LinkName("uiColorButtonOnChanged"), CallingConvention(.Cdecl)]
            internal static extern void UiColorButtonOnChanged(__IntPtr b, __IntPtr f, __IntPtr data);

            [LinkName("uiNewColorButton"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewColorButton();

            [LinkName("uiFormAppend"), CallingConvention(.Cdecl)]
            internal static extern void UiFormAppend(__IntPtr f, char8* label, __IntPtr c, int32 stretchy);

            [LinkName("uiFormNumChildren"), CallingConvention(.Cdecl)]
            internal static extern int32 UiFormNumChildren(__IntPtr f);

            [LinkName("uiFormDelete"), CallingConvention(.Cdecl)]
            internal static extern void UiFormDelete(__IntPtr f, int32 index);

            [LinkName("uiFormPadded"), CallingConvention(.Cdecl)]
            internal static extern int32 UiFormPadded(__IntPtr f);

            [LinkName("uiFormSetPadded"), CallingConvention(.Cdecl)]
            internal static extern void UiFormSetPadded(__IntPtr f, int32 padded);

            [LinkName("uiNewForm"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewForm();

            [LinkName("uiGridAppend"), CallingConvention(.Cdecl)]
            internal static extern void UiGridAppend(__IntPtr g, __IntPtr c, int32 left, int32 top, int32 xspan, int32 yspan, int32 hexpand, uint32 halign, int32 vexpand, uint32 valign);

            [LinkName("uiGridInsertAt"), CallingConvention(.Cdecl)]
            internal static extern void UiGridInsertAt(__IntPtr g, __IntPtr c, __IntPtr existing, uint32 at, int32 xspan, int32 yspan, int32 hexpand, uint32 halign, int32 vexpand, uint32 valign);

            [LinkName("uiGridPadded"), CallingConvention(.Cdecl)]
            internal static extern int32 UiGridPadded(__IntPtr g);

            [LinkName("uiGridSetPadded"), CallingConvention(.Cdecl)]
            internal static extern void UiGridSetPadded(__IntPtr g, int32 padded);

            [LinkName("uiNewGrid"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewGrid();

            [LinkName("uiNewImage"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewImage(double width, double height);

            [LinkName("uiFreeImage"), CallingConvention(.Cdecl)]
            internal static extern void UiFreeImage(__IntPtr i);

            [LinkName("uiImageAppend"), CallingConvention(.Cdecl)]
            internal static extern void UiImageAppend(__IntPtr i, __IntPtr pixels, int32 pixelWidth, int32 pixelHeight, int32 byteStride);

            [LinkName("uiFreeTableValue"), CallingConvention(.Cdecl)]
            internal static extern void UiFreeTableValue(__IntPtr v);

            [LinkName("uiTableValueGetType"), CallingConvention(.Cdecl)]
            internal static extern uint32 UiTableValueGetType(__IntPtr v);

            [LinkName("uiNewTableValueString"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewTableValueString(char8* str);

            [LinkName("uiTableValueString"), CallingConvention(.Cdecl)]
            internal static extern char8* UiTableValueString(__IntPtr v);

            [LinkName("uiNewTableValueImage"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewTableValueImage(__IntPtr img);

            [LinkName("uiTableValueImage"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiTableValueImage(__IntPtr v);

            [LinkName("uiNewTableValueInt"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewTableValueInt(int32 i);

            [LinkName("uiTableValueInt"), CallingConvention(.Cdecl)]
            internal static extern int32 UiTableValueInt(__IntPtr v);

            [LinkName("uiNewTableValueColor"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewTableValueColor(double r, double g, double b, double a);

            [LinkName("uiTableValueColor"), CallingConvention(.Cdecl)]
            internal static extern void UiTableValueColor(__IntPtr v, double* r, double* g, double* b, double* a);

            [LinkName("uiNewTableModel"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewTableModel(__IntPtr mh);

            [LinkName("uiFreeTableModel"), CallingConvention(.Cdecl)]
            internal static extern void UiFreeTableModel(__IntPtr m);

            [LinkName("uiTableModelRowInserted"), CallingConvention(.Cdecl)]
            internal static extern void UiTableModelRowInserted(__IntPtr m, int32 newIndex);

            [LinkName("uiTableModelRowChanged"), CallingConvention(.Cdecl)]
            internal static extern void UiTableModelRowChanged(__IntPtr m, int32 index);

            [LinkName("uiTableModelRowDeleted"), CallingConvention(.Cdecl)]
            internal static extern void UiTableModelRowDeleted(__IntPtr m, int32 oldIndex);

            [LinkName("uiTableAppendTextColumn"), CallingConvention(.Cdecl)]
            internal static extern void UiTableAppendTextColumn(__IntPtr t, char8* name, int32 textModelColumn, int32 textEditableModelColumn, __IntPtr textParams);

            [LinkName("uiTableAppendImageColumn"), CallingConvention(.Cdecl)]
            internal static extern void UiTableAppendImageColumn(__IntPtr t, char8* name, int32 imageModelColumn);

            [LinkName("uiTableAppendImageTextColumn"), CallingConvention(.Cdecl)]
            internal static extern void UiTableAppendImageTextColumn(__IntPtr t, char8* name, int32 imageModelColumn, int32 textModelColumn, int32 textEditableModelColumn, __IntPtr textParams);

            [LinkName("uiTableAppendCheckboxColumn"), CallingConvention(.Cdecl)]
            internal static extern void UiTableAppendCheckboxColumn(__IntPtr t, char8* name, int32 checkboxModelColumn, int32 checkboxEditableModelColumn);

            [LinkName("uiTableAppendCheckboxTextColumn"), CallingConvention(.Cdecl)]
            internal static extern void UiTableAppendCheckboxTextColumn(__IntPtr t, char8* name, int32 checkboxModelColumn, int32 checkboxEditableModelColumn, int32 textModelColumn, int32 textEditableModelColumn, __IntPtr textParams);

            [LinkName("uiTableAppendProgressBarColumn"), CallingConvention(.Cdecl)]
            internal static extern void UiTableAppendProgressBarColumn(__IntPtr t, char8* name, int32 progressModelColumn);

            [LinkName("uiTableAppendButtonColumn"), CallingConvention(.Cdecl)]
            internal static extern void UiTableAppendButtonColumn(__IntPtr t, char8* name, int32 buttonModelColumn, int32 buttonClickableModelColumn);

            [LinkName("uiTableHeaderVisible"), CallingConvention(.Cdecl)]
            internal static extern int32 UiTableHeaderVisible(__IntPtr t);

            [LinkName("uiTableHeaderSetVisible"), CallingConvention(.Cdecl)]
            internal static extern void UiTableHeaderSetVisible(__IntPtr t, int32 visible);

            [LinkName("uiNewTable"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiNewTable(__IntPtr _params);

            [LinkName("uiTableOnRowClicked"), CallingConvention(.Cdecl)]
            internal static extern void UiTableOnRowClicked(__IntPtr t, __IntPtr f, __IntPtr data);

            [LinkName("uiTableOnRowDoubleClicked"), CallingConvention(.Cdecl)]
            internal static extern void UiTableOnRowDoubleClicked(__IntPtr t, __IntPtr f, __IntPtr data);

            [LinkName("uiTableHeaderSetSortIndicator"), CallingConvention(.Cdecl)]
            internal static extern void UiTableHeaderSetSortIndicator(__IntPtr t, int32 column, uint32 indicator);

            [LinkName("uiTableHeaderSortIndicator"), CallingConvention(.Cdecl)]
            internal static extern uint32 UiTableHeaderSortIndicator(__IntPtr t, int32 column);

            [LinkName("uiTableHeaderOnClicked"), CallingConvention(.Cdecl)]
            internal static extern void UiTableHeaderOnClicked(__IntPtr t, __IntPtr f, __IntPtr data);

            [LinkName("uiTableColumnWidth"), CallingConvention(.Cdecl)]
            internal static extern int32 UiTableColumnWidth(__IntPtr t, int32 column);

            [LinkName("uiTableColumnSetWidth"), CallingConvention(.Cdecl)]
            internal static extern void UiTableColumnSetWidth(__IntPtr t, int32 column, int32 width);

            [LinkName("uiTableGetSelectionMode"), CallingConvention(.Cdecl)]
            internal static extern uint32 UiTableGetSelectionMode(__IntPtr t);

            [LinkName("uiTableSetSelectionMode"), CallingConvention(.Cdecl)]
            internal static extern void UiTableSetSelectionMode(__IntPtr t, uint32 mode);

            [LinkName("uiTableOnSelectionChanged"), CallingConvention(.Cdecl)]
            internal static extern void UiTableOnSelectionChanged(__IntPtr t, __IntPtr f, __IntPtr data);

            [LinkName("uiTableGetSelection"), CallingConvention(.Cdecl)]
            internal static extern __IntPtr UiTableGetSelection(__IntPtr t);

            [LinkName("uiTableSetSelection"), CallingConvention(.Cdecl)]
            internal static extern void UiTableSetSelection(__IntPtr t, __IntPtr sel);

            [LinkName("uiFreeTableSelection"), CallingConvention(.Cdecl)]
            internal static extern void UiFreeTableSelection(__IntPtr s);
        }

        public static char8* UiInit(libui.UiInitOptions options)
        {
            var __arg0 = options == null ? null : options.__Instance;
            var ___ret = __Internal.UiInit(__arg0);
            return ___ret;
        }

        public static void UiUninit()
        {
            __Internal.UiUninit();
        }

        public static void UiFreeInitError(char8* err)
        {
            __Internal.UiFreeInitError(err);
        }

        public static void UiMain()
        {
            __Internal.UiMain();
        }

        public static void UiMainSteps()
        {
            __Internal.UiMainSteps();
        }

        public static int32 UiMainStep(int32 wait)
        {
            var ___ret = __Internal.UiMainStep(wait);
            return ___ret;
        }

        public static void UiQuit()
        {
            __Internal.UiQuit();
        }

        public static void UiQueueMain(libui.Delegates.Action___IntPtr f, __IntPtr data)
        {
            var __arg0 = f == null ? null : f.GetFuncPtr();
            __Internal.UiQueueMain(__arg0, data);
        }

        public static void UiTimer(int32 milliseconds, libui.Delegates.Func_int___IntPtr f, __IntPtr data)
        {
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiTimer(milliseconds, __arg1, data);
        }

        public static void UiOnShouldQuit(libui.Delegates.Func_int___IntPtr f, __IntPtr data)
        {
            var __arg0 = f == null ? null : f.GetFuncPtr();
            __Internal.UiOnShouldQuit(__arg0, data);
        }

        /// <summary>Free the memory of a returned string.</summary>
        /// <param name="text">The string to free memory</param>
        /// <remarks>
        /// <para>Every time a string is returned from the library, this method should be called.</para>
        /// <para>Examples of these functions are uiWindowTitle, uiOpenFile, uiSaveFile, and uiEntryText.</para>
        /// <para>It is not required for input strings, e.g. in uiWindowSetTitle.</para>
        /// </remarks>
        public static void UiFreeText(char8* text)
        {
            __Internal.UiFreeText(text);
        }

        /// <summary>Dispose and free all allocated resources.</summary>
        /// <param name="c">uiControl instance.</param>
        /// <remarks>
        /// <para>The platform specific APIs that actually destroy a control (and its children) are called.</para>
        /// <para>Most of the time is needed to be used directly only on the top level windows.</para>
        /// <para>Document ownership.</para>
        /// </remarks>
        public static void UiControlDestroy(libui.UiControl c)
        {
            var __arg0 = c == null ? null : c.__Instance;
            __Internal.UiControlDestroy(__arg0);
        }

        /// <summary>Returns the control's OS-level handle.</summary>
        /// <param name="c">uiControl instance.</param>
        /// <remarks>OS-level handle.</remarks>
        public static uint64 UiControlHandle(libui.UiControl c)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var ___ret = __Internal.UiControlHandle(__arg0);
            return ___ret;
        }

        /// <summary>Returns the parent control.</summary>
        /// <param name="c">uiControl instance.</param>
        /// <remarks>The parent control, `NULL` if detached.</remarks>
        public static libui.UiControl UiControlParent(libui.UiControl c)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var ___ret = __Internal.UiControlParent(__arg0);
            var __result0 = libui.UiControl.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Sets the control's parent.</summary>
        /// <param name="c">uiControl instance.</param>
        /// <param name="parent">The parent control, `NULL` to detach.</param>
        /// <remarks>Document ownership.</remarks>
        public static void UiControlSetParent(libui.UiControl c, libui.UiControl parent)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var __arg1 = parent == null ? null : parent.__Instance;
            __Internal.UiControlSetParent(__arg0, __arg1);
        }

        /// <summary>Returns whether or not the control is a top level control.</summary>
        /// <param name="c">uiControl instance.</param>
        /// <remarks>`TRUE` if top level control, `FALSE` otherwise.</remarks>
        public static int32 UiControlToplevel(libui.UiControl c)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var ___ret = __Internal.UiControlToplevel(__arg0);
            return ___ret;
        }

        /// <summary>Returns whether or not the control is visible.</summary>
        /// <param name="c">uiControl instance.</param>
        /// <remarks>`TRUE` if visible, `FALSE` otherwise.</remarks>
        public static int32 UiControlVisible(libui.UiControl c)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var ___ret = __Internal.UiControlVisible(__arg0);
            return ___ret;
        }

        /// <summary>Shows the control.</summary>
        /// <param name="c">uiControl instance.</param>
        public static void UiControlShow(libui.UiControl c)
        {
            var __arg0 = c == null ? null : c.__Instance;
            __Internal.UiControlShow(__arg0);
        }

        /// <summary>Hides the control.</summary>
        /// <param name="c">uiControl instance.</param>
        /// <remarks>Hidden controls do not take up space within the layout.</remarks>
        public static void UiControlHide(libui.UiControl c)
        {
            var __arg0 = c == null ? null : c.__Instance;
            __Internal.UiControlHide(__arg0);
        }

        /// <summary>Returns whether or not the control is enabled.</summary>
        /// <param name="c">uiControl instance.</param>
        /// <remarks>
        /// <para>Defaults to `true`.</para>
        /// <para>uiControlEnabledToUser</para>
        /// </remarks>
        public static int32 UiControlEnabled(libui.UiControl c)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var ___ret = __Internal.UiControlEnabled(__arg0);
            return ___ret;
        }

        /// <summary>Enables the control.</summary>
        /// <param name="c">uiControl instance.</param>
        public static void UiControlEnable(libui.UiControl c)
        {
            var __arg0 = c == null ? null : c.__Instance;
            __Internal.UiControlEnable(__arg0);
        }

        /// <summary>Disables the control.</summary>
        /// <param name="c">uiControl instance.</param>
        public static void UiControlDisable(libui.UiControl c)
        {
            var __arg0 = c == null ? null : c.__Instance;
            __Internal.UiControlDisable(__arg0);
        }

        /// <summary>Allocates a uiControl.</summary>
        /// <param name="n">Size of type to allocate.</param>
        /// <remarks>
        /// <para>Helper to allocate new controls.</para>
        /// <para>Document parameters</para>
        /// </remarks>
        public static libui.UiControl UiAllocControl(uint64 n, uint32 OSsig, uint32 typesig, char8* typenamestr)
        {
            var ___ret = __Internal.UiAllocControl(n, OSsig, typesig, typenamestr);
            var __result0 = libui.UiControl.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Frees the memory associated with the control reference.</summary>
        /// <param name="c">uiControl instance.</param>
        /// <remarks>This method is public only for writing custom controls.</remarks>
        public static void UiFreeControl(libui.UiControl c)
        {
            var __arg0 = c == null ? null : c.__Instance;
            __Internal.UiFreeControl(__arg0);
        }

        /// <summary>Makes sure the control's parent can be set to</summary>
        /// <param name="c">uiControl instance.</param>
        /// <param name="parent">uiControl instance.</param>
        /// <remarks>
        /// <para>Make sure all controls have these</para>
        /// <para>This will crash the application if `FALSE`.</para>
        /// </remarks>
        public static void UiControlVerifySetParent(libui.UiControl c, libui.UiControl parent)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var __arg1 = parent == null ? null : parent.__Instance;
            __Internal.UiControlVerifySetParent(__arg0, __arg1);
        }

        /// <summary>Returns whether or not the control can be interacted with by the user.</summary>
        /// <param name="c">uiControl instance.</param>
        /// <remarks>
        /// <para>Checks if the control and all it's parents are enabled to make sure it can</para>
        /// <para>be interacted with by the user.</para>
        /// <para>`TRUE` if enabled, `FALSE` otherwise.</para>
        /// <para>uiControlEnabled</para>
        /// </remarks>
        public static int32 UiControlEnabledToUser(libui.UiControl c)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var ___ret = __Internal.UiControlEnabledToUser(__arg0);
            return ___ret;
        }

        public static void UiUserBugCannotSetParentOnToplevel(char8* type)
        {
            __Internal.UiUserBugCannotSetParentOnToplevel(type);
        }

        /// <summary>Returns the window title.</summary>
        /// <param name="w">uiWindow instance.</param>
        /// <remarks>The window title text.A `NUL` terminated UTF-8 string.Caller is responsible for freeing the data with `uiFreeText()`.</remarks>
        public static char8* UiWindowTitle(libui.UiWindow w)
        {
            var __arg0 = w == null ? null : w.__Instance;
            var ___ret = __Internal.UiWindowTitle(__arg0);
            return ___ret;
        }

        /// <summary>Sets the window title.</summary>
        /// <param name="w">uiWindow instance.</param>
        /// <param name="title">Window title text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <remarks>This method is merely a hint and may be ignored on unix platforms.</remarks>
        public static void UiWindowSetTitle(libui.UiWindow w, char8* title)
        {
            var __arg0 = w == null ? null : w.__Instance;
            __Internal.UiWindowSetTitle(__arg0, title);
        }

        /// <summary>Gets the window position.</summary>
        /// <param name="w">uiWindow instance.</param>
        /// <param name="x">X position of the window.</param>
        /// <param name="y">Y position of the window.</param>
        /// <remarks>
        /// <para>Coordinates are measured from the top left corner of the screen.</para>
        /// <para>This method may return inaccurate or dummy values on Unix platforms.</para>
        /// </remarks>
        public static void UiWindowPosition(libui.UiWindow w, ref int32 x, ref int32 y)
        {
            var __arg0 = w == null ? null : w.__Instance;
            int32* __x1 = &x;
            {
                var __arg1 = __x1;
                int32* __y2 = &y;
                {
                    var __arg2 = __y2;
                    __Internal.UiWindowPosition(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Moves the window to the specified position.</summary>
        /// <param name="w">uiWindow instance.</param>
        /// <param name="x">New x position of the window.</param>
        /// <param name="y">New y position of the window.</param>
        /// <remarks>
        /// <para>Coordinates are measured from the top left corner of the screen.</para>
        /// <para>This method is merely a hint and may be ignored on Unix platforms.</para>
        /// </remarks>
        public static void UiWindowSetPosition(libui.UiWindow w, int32 x, int32 y)
        {
            var __arg0 = w == null ? null : w.__Instance;
            __Internal.UiWindowSetPosition(__arg0, x, y);
        }

        /// <summary>Registers a callback for when the window moved.</summary>
        /// <param name="w">uiWindow instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that triggered the callback.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>
        /// <para>Only one callback can be registered at a time.</para>
        /// <para>The callback is not triggered when calling uiWindowSetPosition().</para>
        /// </remarks>
        public static void UiWindowOnPositionChanged(libui.UiWindow w, libui.Delegates.Action___IntPtr___IntPtr f, __IntPtr data)
        {
            var __arg0 = w == null ? null : w.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiWindowOnPositionChanged(__arg0, __arg1, data);
        }

        /// <summary>Gets the window content size.</summary>
        /// <param name="w">uiWindow instance.</param>
        /// <param name="width">Window content width.</param>
        /// <param name="height">Window content height.</param>
        /// <remarks>The content size does NOT include window decorations like menus or title bars.</remarks>
        public static void UiWindowContentSize(libui.UiWindow w, ref int32 width, ref int32 height)
        {
            var __arg0 = w == null ? null : w.__Instance;
            int32* __width1 = &width;
            {
                var __arg1 = __width1;
                int32* __height2 = &height;
                {
                    var __arg2 = __height2;
                    __Internal.UiWindowContentSize(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Sets the window content size.</summary>
        /// <param name="w">uiWindow instance.</param>
        /// <param name="width">Window content width to set.</param>
        /// <param name="height">Window content height to set.</param>
        /// <remarks>
        /// <para>The content size does NOT include window decorations like menus or title bars.</para>
        /// <para>This method is merely a hint and may be ignored by the system.</para>
        /// </remarks>
        public static void UiWindowSetContentSize(libui.UiWindow w, int32 width, int32 height)
        {
            var __arg0 = w == null ? null : w.__Instance;
            __Internal.UiWindowSetContentSize(__arg0, width, height);
        }

        /// <summary>Returns whether or not the window is full screen.</summary>
        /// <param name="w">uiWindow instance.</param>
        /// <remarks>`TRUE` if full screen, `FALSE` otherwise. [Default: `FALSE`]</remarks>
        public static int32 UiWindowFullscreen(libui.UiWindow w)
        {
            var __arg0 = w == null ? null : w.__Instance;
            var ___ret = __Internal.UiWindowFullscreen(__arg0);
            return ___ret;
        }

        /// <summary>Sets whether or not the window is full screen.</summary>
        /// <param name="w">uiWindow instance.</param>
        /// <param name="fullscreen">`TRUE` to make window full screen, `FALSE` otherwise.</param>
        /// <remarks>This method is merely a hint and may be ignored by the system.</remarks>
        public static void UiWindowSetFullscreen(libui.UiWindow w, int32 fullscreen)
        {
            var __arg0 = w == null ? null : w.__Instance;
            __Internal.UiWindowSetFullscreen(__arg0, fullscreen);
        }

        /// <summary>Registers a callback for when the window content size is changed.</summary>
        /// <param name="w">uiWindow instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that triggered the callback.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>
        /// <para>The callback is not triggered when calling uiWindowSetContentSize().</para>
        /// <para>Only one callback can be registered at a time.</para>
        /// </remarks>
        public static void UiWindowOnContentSizeChanged(libui.UiWindow w, libui.Delegates.Action___IntPtr___IntPtr f, __IntPtr data)
        {
            var __arg0 = w == null ? null : w.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiWindowOnContentSizeChanged(__arg0, __arg1, data);
        }

        /// <summary>Registers a callback for when the window is to be closed.</summary>
        /// <param name="w">uiWindow instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that triggered the callback.User data registered with the sender instance.Return:`TRUE` to destroys the window.`FALSE` to abort closing and keep the window alive and visible.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>Only one callback can be registered at a time.</remarks>
        public static void UiWindowOnClosing(libui.UiWindow w, libui.Delegates.Func_int___IntPtr___IntPtr f, __IntPtr data)
        {
            var __arg0 = w == null ? null : w.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiWindowOnClosing(__arg0, __arg1, data);
        }

        /// <summary>Registers a callback for when the window focus changes.</summary>
        /// <param name="w">uiWindow instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that triggered the callback.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>Only one callback can be registered at a time.</remarks>
        public static void UiWindowOnFocusChanged(libui.UiWindow w, libui.Delegates.Action___IntPtr___IntPtr f, __IntPtr data)
        {
            var __arg0 = w == null ? null : w.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiWindowOnFocusChanged(__arg0, __arg1, data);
        }

        /// <summary>Returns whether or not the window is focused.</summary>
        /// <param name="w">uiWindow instance.</param>
        /// <remarks>`TRUE` if window is focused, `FALSE` otherwise.</remarks>
        public static int32 UiWindowFocused(libui.UiWindow w)
        {
            var __arg0 = w == null ? null : w.__Instance;
            var ___ret = __Internal.UiWindowFocused(__arg0);
            return ___ret;
        }

        /// <summary>Returns whether or not the window is borderless.</summary>
        /// <param name="w">uiWindow instance.</param>
        /// <remarks>`TRUE` if window is borderless, `FALSE` otherwise. [Default: `TODO`]</remarks>
        public static int32 UiWindowBorderless(libui.UiWindow w)
        {
            var __arg0 = w == null ? null : w.__Instance;
            var ___ret = __Internal.UiWindowBorderless(__arg0);
            return ___ret;
        }

        /// <summary>Sets whether or not the window is borderless.</summary>
        /// <param name="w">uiWindow instance.</param>
        /// <param name="borderless">`TRUE` to make window borderless, `FALSE` otherwise.</param>
        /// <remarks>This method is merely a hint and may be ignored by the system.</remarks>
        public static void UiWindowSetBorderless(libui.UiWindow w, int32 borderless)
        {
            var __arg0 = w == null ? null : w.__Instance;
            __Internal.UiWindowSetBorderless(__arg0, borderless);
        }

        /// <summary>Sets the window's child.</summary>
        /// <param name="w">uiWindow instance.</param>
        /// <param name="child">Control to be made child.</param>
        public static void UiWindowSetChild(libui.UiWindow w, libui.UiControl child)
        {
            var __arg0 = w == null ? null : w.__Instance;
            var __arg1 = child == null ? null : child.__Instance;
            __Internal.UiWindowSetChild(__arg0, __arg1);
        }

        /// <summary>Returns whether or not the window has a margin.</summary>
        /// <param name="w">uiWindow instance.</param>
        /// <remarks>`TRUE` if window has a margin, `FALSE` otherwise. [Default: `FALSE`]</remarks>
        public static int32 UiWindowMargined(libui.UiWindow w)
        {
            var __arg0 = w == null ? null : w.__Instance;
            var ___ret = __Internal.UiWindowMargined(__arg0);
            return ___ret;
        }

        /// <summary>Sets whether or not the window has a margin.</summary>
        /// <param name="w">uiWindow instance.</param>
        /// <param name="margined">`TRUE` to set a window margin, `FALSE` otherwise.</param>
        /// <remarks>The margin size is determined by the OS defaults.</remarks>
        public static void UiWindowSetMargined(libui.UiWindow w, int32 margined)
        {
            var __arg0 = w == null ? null : w.__Instance;
            __Internal.UiWindowSetMargined(__arg0, margined);
        }

        /// <summary>Returns whether or not the window is user resizeable.</summary>
        /// <param name="w">uiWindow instance.</param>
        /// <remarks>`TRUE` if window is resizable, `FALSE` otherwise. [Default: `TRUE`]</remarks>
        public static int32 UiWindowResizeable(libui.UiWindow w)
        {
            var __arg0 = w == null ? null : w.__Instance;
            var ___ret = __Internal.UiWindowResizeable(__arg0);
            return ___ret;
        }

        /// <summary>Sets whether or not the window is user resizeable.</summary>
        /// <param name="w">uiWindow instance.</param>
        /// <param name="resizeable">`TRUE` to make window resizable, `FALSE` otherwise.</param>
        /// <remarks>This method is merely a hint and may be ignored by the system.</remarks>
        public static void UiWindowSetResizeable(libui.UiWindow w, int32 resizeable)
        {
            var __arg0 = w == null ? null : w.__Instance;
            __Internal.UiWindowSetResizeable(__arg0, resizeable);
        }

        /// <summary>Creates a new uiWindow.</summary>
        /// <param name="title">Window title text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <param name="width">Window width.</param>
        /// <param name="height">Window height.</param>
        /// <param name="hasMenubar">Whether or not the window should display a menu bar.</param>
        /// <remarks>A new uiWindow instance.</remarks>
        public static libui.UiWindow UiNewWindow(char8* title, int32 width, int32 height, int32 hasMenubar)
        {
            var ___ret = __Internal.UiNewWindow(title, width, height, hasMenubar);
            var __result0 = libui.UiWindow.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Returns the button label text.</summary>
        /// <param name="b">uiButton instance.</param>
        /// <remarks>The text of the label.A `NUL` terminated UTF-8 string.Caller is responsible for freeing the data with `uiFreeText()`.</remarks>
        public static char8* UiButtonText(libui.UiButton b)
        {
            var __arg0 = b == null ? null : b.__Instance;
            var ___ret = __Internal.UiButtonText(__arg0);
            return ___ret;
        }

        /// <summary>Sets the button label text.</summary>
        /// <param name="b">uiButton instance.</param>
        /// <param name="text">Label text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        public static void UiButtonSetText(libui.UiButton b, char8* text)
        {
            var __arg0 = b == null ? null : b.__Instance;
            __Internal.UiButtonSetText(__arg0, text);
        }

        /// <summary>Registers a callback for when the button is clicked.</summary>
        /// <param name="b">uiButton instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that triggered the callback.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>Only one callback can be registered at a time.</remarks>
        public static void UiButtonOnClicked(libui.UiButton b, libui.Delegates.Action___IntPtr___IntPtr f, __IntPtr data)
        {
            var __arg0 = b == null ? null : b.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiButtonOnClicked(__arg0, __arg1, data);
        }

        /// <summary>Creates a new button.</summary>
        /// <param name="text">Label text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <remarks>A new uiButton instance.</remarks>
        public static libui.UiButton UiNewButton(char8* text)
        {
            var ___ret = __Internal.UiNewButton(text);
            var __result0 = libui.UiButton.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Appends a control to the box.</summary>
        /// <param name="b">uiBox instance.</param>
        /// <param name="child">Control instance to append.</param>
        /// <param name="stretchy">`TRUE` to stretch control, `FALSE` otherwise.</param>
        /// <remarks>
        /// <para>Stretchy items expand to use the remaining space within the box.</para>
        /// <para>In the case of multiple stretchy items the space is shared equally.</para>
        /// </remarks>
        public static void UiBoxAppend(libui.UiBox b, libui.UiControl child, int32 stretchy)
        {
            var __arg0 = b == null ? null : b.__Instance;
            var __arg1 = child == null ? null : child.__Instance;
            __Internal.UiBoxAppend(__arg0, __arg1, stretchy);
        }

        /// <summary>Returns the number of controls contained within the box.</summary>
        /// <param name="b">uiBox instance.</param>
        /// <remarks>Number of children.</remarks>
        public static int32 UiBoxNumChildren(libui.UiBox b)
        {
            var __arg0 = b == null ? null : b.__Instance;
            var ___ret = __Internal.UiBoxNumChildren(__arg0);
            return ___ret;
        }

        /// <summary>Removes the control atfrom the box.</summary>
        /// <param name="b">uiBox instance.</param>
        /// <param name="index">Index of control to be removed.</param>
        /// <remarks>The control neither destroyed nor freed.</remarks>
        public static void UiBoxDelete(libui.UiBox b, int32 index)
        {
            var __arg0 = b == null ? null : b.__Instance;
            __Internal.UiBoxDelete(__arg0, index);
        }

        /// <summary>Returns whether or not controls within the box are padded.</summary>
        /// <param name="b">uiBox instance.</param>
        /// <remarks>
        /// <para>Padding is defined as space between individual controls.</para>
        /// <para>`TRUE` if controls are padded, `FALSE` otherwise. [Default: `TODO`]</para>
        /// </remarks>
        public static int32 UiBoxPadded(libui.UiBox b)
        {
            var __arg0 = b == null ? null : b.__Instance;
            var ___ret = __Internal.UiBoxPadded(__arg0);
            return ___ret;
        }

        /// <summary>Sets whether or not controls within the box are padded.</summary>
        /// <param name="b">uiBox instance.</param>
        /// <param name="padded">`TRUE` to make controls padded, `FALSE` otherwise.</param>
        /// <remarks>
        /// <para>Padding is defined as space between individual controls.</para>
        /// <para>The padding size is determined by the OS defaults.</para>
        /// </remarks>
        public static void UiBoxSetPadded(libui.UiBox b, int32 padded)
        {
            var __arg0 = b == null ? null : b.__Instance;
            __Internal.UiBoxSetPadded(__arg0, padded);
        }

        /// <summary>Creates a new horizontal box.</summary>
        /// <remarks>
        /// <para>Controls within the box are placed next to each other horizontally.</para>
        /// <para>A new uiBox instance.</para>
        /// </remarks>
        public static libui.UiBox UiNewHorizontalBox()
        {
            var ___ret = __Internal.UiNewHorizontalBox();
            var __result0 = libui.UiBox.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Creates a new vertical box.</summary>
        /// <remarks>
        /// <para>Controls within the box are placed next to each other vertically.</para>
        /// <para>A new uiBox instance.</para>
        /// </remarks>
        public static libui.UiBox UiNewVerticalBox()
        {
            var ___ret = __Internal.UiNewVerticalBox();
            var __result0 = libui.UiBox.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Returns the checkbox label text.</summary>
        /// <param name="c">uiCheckbox instance.</param>
        /// <remarks>The text of the label.A `NUL` terminated UTF-8 string.Caller is responsible for freeing the data with `uiFreeText()`.</remarks>
        public static char8* UiCheckboxText(libui.UiCheckbox c)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var ___ret = __Internal.UiCheckboxText(__arg0);
            return ___ret;
        }

        /// <summary>Sets the checkbox label text.</summary>
        /// <param name="c">uiCheckbox instance.</param>
        /// <param name="text">Label text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        public static void UiCheckboxSetText(libui.UiCheckbox c, char8* text)
        {
            var __arg0 = c == null ? null : c.__Instance;
            __Internal.UiCheckboxSetText(__arg0, text);
        }

        /// <summary>Registers a callback for when the checkbox is toggled by the user.</summary>
        /// <param name="c">uiCheckbox instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that initiated the callback.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>
        /// <para>The callback is not triggered when calling uiCheckboxSetChecked().</para>
        /// <para>Only one callback can be registered at a time.</para>
        /// </remarks>
        public static void UiCheckboxOnToggled(libui.UiCheckbox c, libui.Delegates.Action___IntPtr___IntPtr f, __IntPtr data)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiCheckboxOnToggled(__arg0, __arg1, data);
        }

        /// <summary>Returns whether or the checkbox is checked.</summary>
        /// <param name="c">uiCheckbox instance.</param>
        /// <remarks>`TRUE` if checked, `FALSE` otherwise. [Default: `FALSE`]</remarks>
        public static int32 UiCheckboxChecked(libui.UiCheckbox c)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var ___ret = __Internal.UiCheckboxChecked(__arg0);
            return ___ret;
        }

        /// <summary>Sets whether or not the checkbox is checked.</summary>
        /// <param name="c">uiCheckbox instance.</param>
        /// <param name="checked">`TRUE` to check box, `FALSE` otherwise.</param>
        public static void UiCheckboxSetChecked(libui.UiCheckbox c, int32 _checked)
        {
            var __arg0 = c == null ? null : c.__Instance;
            __Internal.UiCheckboxSetChecked(__arg0, _checked);
        }

        /// <summary>Creates a new checkbox.</summary>
        /// <param name="text">Label text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <remarks>A new uiCheckbox instance.</remarks>
        public static libui.UiCheckbox UiNewCheckbox(char8* text)
        {
            var ___ret = __Internal.UiNewCheckbox(text);
            var __result0 = libui.UiCheckbox.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Returns the entry's text.</summary>
        /// <param name="e">uiEntry instance.</param>
        /// <remarks>The text of the entry.A `NUL` terminated UTF-8 string.Caller is responsible for freeing the data with `uiFreeText()`.</remarks>
        public static char8* UiEntryText(libui.UiEntry e)
        {
            var __arg0 = e == null ? null : e.__Instance;
            var ___ret = __Internal.UiEntryText(__arg0);
            return ___ret;
        }

        /// <summary>Sets the entry's text.</summary>
        /// <param name="e">uiEntry instance.</param>
        /// <param name="text">Entry text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        public static void UiEntrySetText(libui.UiEntry e, char8* text)
        {
            var __arg0 = e == null ? null : e.__Instance;
            __Internal.UiEntrySetText(__arg0, text);
        }

        /// <summary>Registers a callback for when the user changes the entry's text.</summary>
        /// <param name="e">uiEntry instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that initiated the callback.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>The callback is not triggered when calling uiEntrySetText().</remarks>
        public static void UiEntryOnChanged(libui.UiEntry e, libui.Delegates.Action___IntPtr___IntPtr f, __IntPtr data)
        {
            var __arg0 = e == null ? null : e.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiEntryOnChanged(__arg0, __arg1, data);
        }

        /// <summary>Returns whether or not the entry's text can be changed.</summary>
        /// <param name="e">uiEntry instance.</param>
        /// <remarks>`TRUE` if read only, `FALSE` otherwise. [Default: `FALSE`]</remarks>
        public static int32 UiEntryReadOnly(libui.UiEntry e)
        {
            var __arg0 = e == null ? null : e.__Instance;
            var ___ret = __Internal.UiEntryReadOnly(__arg0);
            return ___ret;
        }

        /// <summary>Sets whether or not the entry's text is read only.</summary>
        /// <param name="e">uiEntry instance.</param>
        /// <param name="readonly">`TRUE` to make read only, `FALSE` otherwise.</param>
        public static void UiEntrySetReadOnly(libui.UiEntry e, int32 _readonly)
        {
            var __arg0 = e == null ? null : e.__Instance;
            __Internal.UiEntrySetReadOnly(__arg0, _readonly);
        }

        /// <summary>Creates a new entry.</summary>
        /// <remarks>A new uiEntry instance.</remarks>
        public static libui.UiEntry UiNewEntry()
        {
            var ___ret = __Internal.UiNewEntry();
            var __result0 = libui.UiEntry.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Creates a new entry suitable for sensitive inputs like passwords.</summary>
        /// <remarks>
        /// <para>The entered text is NOT readable by the user but masked as *******.</para>
        /// <para>A new uiEntry instance.</para>
        /// </remarks>
        public static libui.UiEntry UiNewPasswordEntry()
        {
            var ___ret = __Internal.UiNewPasswordEntry();
            var __result0 = libui.UiEntry.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Creates a new entry suitable for search.</summary>
        /// <remarks>
        /// <para>Some systems will deliberately delay the uiEntryOnChanged() callback for</para>
        /// <para>a more natural feel.</para>
        /// <para>A new uiEntry instance.</para>
        /// </remarks>
        public static libui.UiEntry UiNewSearchEntry()
        {
            var ___ret = __Internal.UiNewSearchEntry();
            var __result0 = libui.UiEntry.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Returns the label text.</summary>
        /// <param name="l">uiLabel instance.</param>
        /// <remarks>The text of the label.A `NUL` terminated UTF-8 string.Caller is responsible for freeing the data with `uiFreeText()`.</remarks>
        public static char8* UiLabelText(libui.UiLabel l)
        {
            var __arg0 = l == null ? null : l.__Instance;
            var ___ret = __Internal.UiLabelText(__arg0);
            return ___ret;
        }

        /// <summary>Sets the label text.</summary>
        /// <param name="l">uiLabel instance.</param>
        /// <param name="text">Label text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        public static void UiLabelSetText(libui.UiLabel l, char8* text)
        {
            var __arg0 = l == null ? null : l.__Instance;
            __Internal.UiLabelSetText(__arg0, text);
        }

        /// <summary>Creates a new label.</summary>
        /// <param name="text">Label text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <remarks>A new uiLabel instance.</remarks>
        public static libui.UiLabel UiNewLabel(char8* text)
        {
            var ___ret = __Internal.UiNewLabel(text);
            var __result0 = libui.UiLabel.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Returns the index of the tab selected.</summary>
        /// <param name="c">uiTab instance.</param>
        /// <remarks>Index of the tab selected</remarks>
        public static int32 UiTabSelected(libui.UiTab t)
        {
            var __arg0 = t == null ? null : t.__Instance;
            var ___ret = __Internal.UiTabSelected(__arg0);
            return ___ret;
        }

        /// <summary>Sets the tab selected.</summary>
        /// <param name="c">uiTab instance.</param>
        /// <param name="index">Index of the tab to be selected</param>
        /// <remarks>
        /// <para>Themust be in the range [0, uiTabNumPages(t) - 1].</para>
        /// <para>If out of bounds, the selection is not changed.</para>
        /// </remarks>
        public static void UiTabSetSelected(libui.UiTab t, int32 index)
        {
            var __arg0 = t == null ? null : t.__Instance;
            __Internal.UiTabSetSelected(__arg0, index);
        }

        /// <summary>Registers a callback for when a tab is selected.</summary>
        /// <param name="t">uiTab instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that triggered the callback.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>
        /// <para>The callback is not triggered when calling uiTabSetSelected(),</para>
        /// <para>Only one callback can be registered at a time.</para>
        /// </remarks>
        public static void UiTabOnSelected(libui.UiTab t, libui.Delegates.Action___IntPtr___IntPtr f, __IntPtr data)
        {
            var __arg0 = t == null ? null : t.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiTabOnSelected(__arg0, __arg1, data);
        }

        /// <summary>Appends a control in form of a page/tab with label.</summary>
        /// <param name="t">uiTab instance.</param>
        /// <param name="name">Label text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <param name="c">Control to append.</param>
        public static void UiTabAppend(libui.UiTab t, char8* name, libui.UiControl c)
        {
            var __arg0 = t == null ? null : t.__Instance;
            var __arg2 = c == null ? null : c.__Instance;
            __Internal.UiTabAppend(__arg0, name, __arg2);
        }

        /// <summary>Inserts a control in form of a page/tab with label at</summary>
        /// <param name="t">uiTab instance.</param>
        /// <param name="name">Label text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <param name="index">Index at which to insert the control.</param>
        /// <param name="c">Control to insert.</param>
        public static void UiTabInsertAt(libui.UiTab t, char8* name, int32 index, libui.UiControl c)
        {
            var __arg0 = t == null ? null : t.__Instance;
            var __arg3 = c == null ? null : c.__Instance;
            __Internal.UiTabInsertAt(__arg0, name, index, __arg3);
        }

        /// <summary>Removes the control at</summary>
        /// <param name="t">uiTab instance.</param>
        /// <param name="index">Index of the control to be removed.</param>
        /// <remarks>The control is neither destroyed nor freed.</remarks>
        public static void UiTabDelete(libui.UiTab t, int32 index)
        {
            var __arg0 = t == null ? null : t.__Instance;
            __Internal.UiTabDelete(__arg0, index);
        }

        /// <summary>Returns the number of pages contained.</summary>
        /// <param name="t">uiTab instance.</param>
        /// <remarks>Number of pages.</remarks>
        public static int32 UiTabNumPages(libui.UiTab t)
        {
            var __arg0 = t == null ? null : t.__Instance;
            var ___ret = __Internal.UiTabNumPages(__arg0);
            return ___ret;
        }

        /// <summary>Returns whether or not the page/tab athas a margin.</summary>
        /// <param name="t">uiTab instance.</param>
        /// <param name="index">Index to check if it has a margin.</param>
        /// <remarks>`TRUE` if the tab has a margin, `FALSE` otherwise. [Default: `TODO`]</remarks>
        public static int32 UiTabMargined(libui.UiTab t, int32 index)
        {
            var __arg0 = t == null ? null : t.__Instance;
            var ___ret = __Internal.UiTabMargined(__arg0, index);
            return ___ret;
        }

        /// <summary>Sets whether or not the page/tab athas a margin.</summary>
        /// <param name="t">uiTab instance.</param>
        /// <param name="index">Index of the tab/page to un/set margin for.</param>
        /// <param name="margined">`TRUE` to set a margin for tab at`FALSE` otherwise.</param>
        /// <remarks>The margin size is determined by the OS defaults.</remarks>
        public static void UiTabSetMargined(libui.UiTab t, int32 index, int32 margined)
        {
            var __arg0 = t == null ? null : t.__Instance;
            __Internal.UiTabSetMargined(__arg0, index, margined);
        }

        /// <summary>Creates a new tab container.</summary>
        /// <returns>A new uiTab instance.</returns>
        public static libui.UiTab UiNewTab()
        {
            var ___ret = __Internal.UiNewTab();
            var __result0 = libui.UiTab.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Returns the group title.</summary>
        /// <param name="g">uiGroup instance.</param>
        /// <remarks>The group title text.A `NUL` terminated UTF-8 string.Caller is responsible for freeing the data with `uiFreeText()`.</remarks>
        public static char8* UiGroupTitle(libui.UiGroup g)
        {
            var __arg0 = g == null ? null : g.__Instance;
            var ___ret = __Internal.UiGroupTitle(__arg0);
            return ___ret;
        }

        /// <summary>Sets the group title.</summary>
        /// <param name="g">uiGroup instance.</param>
        /// <param name="title">Group title text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        public static void UiGroupSetTitle(libui.UiGroup g, char8* title)
        {
            var __arg0 = g == null ? null : g.__Instance;
            __Internal.UiGroupSetTitle(__arg0, title);
        }

        /// <summary>Sets the group's child.</summary>
        /// <param name="g">uiGroup instance.</param>
        /// <param name="c">uiControl child instance, or `NULL`.</param>
        public static void UiGroupSetChild(libui.UiGroup g, libui.UiControl c)
        {
            var __arg0 = g == null ? null : g.__Instance;
            var __arg1 = c == null ? null : c.__Instance;
            __Internal.UiGroupSetChild(__arg0, __arg1);
        }

        /// <summary>Returns whether or not the group has a margin.</summary>
        /// <param name="g">uiGroup instance.</param>
        /// <remarks>`TRUE` if the group has a margin, `FALSE` otherwise. [Default: `TODO`]</remarks>
        public static int32 UiGroupMargined(libui.UiGroup g)
        {
            var __arg0 = g == null ? null : g.__Instance;
            var ___ret = __Internal.UiGroupMargined(__arg0);
            return ___ret;
        }

        /// <summary>Sets whether or not the group has a margin.</summary>
        /// <param name="g">uiGroup instance.</param>
        /// <param name="margined">`TRUE` to set a margin, `FALSE` otherwise.</param>
        /// <remarks>The margin size is determined by the OS defaults.</remarks>
        public static void UiGroupSetMargined(libui.UiGroup g, int32 margined)
        {
            var __arg0 = g == null ? null : g.__Instance;
            __Internal.UiGroupSetMargined(__arg0, margined);
        }

        /// <summary>Creates a new group.</summary>
        /// <param name="title">Group title text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <remarks>A new uiGroup instance.</remarks>
        public static libui.UiGroup UiNewGroup(char8* title)
        {
            var ___ret = __Internal.UiNewGroup(title);
            var __result0 = libui.UiGroup.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Returns the spinbox value.</summary>
        /// <param name="s">uiSpinbox instance.</param>
        /// <remarks>Spinbox value.</remarks>
        public static int32 UiSpinboxValue(libui.UiSpinbox s)
        {
            var __arg0 = s == null ? null : s.__Instance;
            var ___ret = __Internal.UiSpinboxValue(__arg0);
            return ___ret;
        }

        /// <summary>Sets the spinbox value.</summary>
        /// <param name="s">uiSpinbox instance.</param>
        /// <param name="value">Value to set.</param>
        /// <remarks>Setting a value out of range will clamp to the nearest value in range.</remarks>
        public static void UiSpinboxSetValue(libui.UiSpinbox s, int32 value)
        {
            var __arg0 = s == null ? null : s.__Instance;
            __Internal.UiSpinboxSetValue(__arg0, value);
        }

        /// <summary>Registers a callback for when the spinbox value is changed by the user.</summary>
        /// <param name="s">uiSpinbox instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that triggered the callback.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>
        /// <para>The callback is not triggered when calling uiSpinboxSetValue().</para>
        /// <para>Only one callback can be registered at a time.</para>
        /// </remarks>
        public static void UiSpinboxOnChanged(libui.UiSpinbox s, libui.Delegates.Action___IntPtr___IntPtr f, __IntPtr data)
        {
            var __arg0 = s == null ? null : s.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiSpinboxOnChanged(__arg0, __arg1, data);
        }

        /// <summary>Creates a new spinbox.</summary>
        /// <param name="min">Minimum value.</param>
        /// <param name="max">Maximum value.</param>
        /// <remarks>
        /// <para>The initial spinbox value equals the minimum value.</para>
        /// <para>In the current implementationandare swapped if `min&gt;max`.</para>
        /// <para>This may change in the future though. See TODO.</para>
        /// <para>A new uiSpinbox instance.</para>
        /// <para>complain or disallow min&gt;max?</para>
        /// </remarks>
        public static libui.UiSpinbox UiNewSpinbox(int32 min, int32 max)
        {
            var ___ret = __Internal.UiNewSpinbox(min, max);
            var __result0 = libui.UiSpinbox.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Returns the slider value.</summary>
        /// <param name="s">uiSlider instance.</param>
        /// <remarks>Slider value.</remarks>
        public static int32 UiSliderValue(libui.UiSlider s)
        {
            var __arg0 = s == null ? null : s.__Instance;
            var ___ret = __Internal.UiSliderValue(__arg0);
            return ___ret;
        }

        /// <summary>Sets the slider value.</summary>
        /// <param name="s">uiSlider intance.</param>
        /// <param name="value">Value to set.</param>
        public static void UiSliderSetValue(libui.UiSlider s, int32 value)
        {
            var __arg0 = s == null ? null : s.__Instance;
            __Internal.UiSliderSetValue(__arg0, value);
        }

        /// <summary>Returns whether or not the slider has a tool tip.</summary>
        /// <param name="s">uiSlider instance.</param>
        /// <remarks>`TRUE` if a tool tip is present, `FALSE` otherwise. [Default `TRUE`]</remarks>
        public static int32 UiSliderHasToolTip(libui.UiSlider s)
        {
            var __arg0 = s == null ? null : s.__Instance;
            var ___ret = __Internal.UiSliderHasToolTip(__arg0);
            return ___ret;
        }

        /// <summary>Sets whether or not the slider has a tool tip.</summary>
        /// <param name="s">uiSlider instance.</param>
        /// <param name="hasToolTip">`TRUE` to display a tool tip, `FALSE` to display no tool tip.</param>
        public static void UiSliderSetHasToolTip(libui.UiSlider s, int32 hasToolTip)
        {
            var __arg0 = s == null ? null : s.__Instance;
            __Internal.UiSliderSetHasToolTip(__arg0, hasToolTip);
        }

        /// <summary>Registers a callback for when the slider value is changed by the user.</summary>
        /// <param name="s">uiSlider instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that triggered the callback.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>
        /// <para>The callback is not triggered when calling uiSliderSetValue().</para>
        /// <para>Only one callback can be registered at a time.</para>
        /// </remarks>
        public static void UiSliderOnChanged(libui.UiSlider s, libui.Delegates.Action___IntPtr___IntPtr f, __IntPtr data)
        {
            var __arg0 = s == null ? null : s.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiSliderOnChanged(__arg0, __arg1, data);
        }

        /// <summary>Registers a callback for when the slider is released from dragging.</summary>
        /// <param name="s">uiSlider instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that triggered the callback.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>Only one callback can be registered at a time.</remarks>
        public static void UiSliderOnReleased(libui.UiSlider s, libui.Delegates.Action___IntPtr___IntPtr f, __IntPtr data)
        {
            var __arg0 = s == null ? null : s.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiSliderOnReleased(__arg0, __arg1, data);
        }

        /// <summary>Sets the slider range.</summary>
        /// <param name="s">uiSlider instance.</param>
        /// <param name="min">Minimum value.</param>
        /// <param name="max">Maximum value.</param>
        /// <remarks>
        /// <para>Make sure to clamp the slider value to the nearest value in range - should</para>
        /// <para>it be out of range. Call uiSliderOnChanged() in such a case.</para>
        /// </remarks>
        public static void UiSliderSetRange(libui.UiSlider s, int32 min, int32 max)
        {
            var __arg0 = s == null ? null : s.__Instance;
            __Internal.UiSliderSetRange(__arg0, min, max);
        }

        /// <summary>Creates a new slider.</summary>
        /// <param name="min">Minimum value.</param>
        /// <param name="max">Maximum value.</param>
        /// <remarks>
        /// <para>The initial slider value equals the minimum value.</para>
        /// <para>In the current implementationandare swapped if `min&gt;max`.</para>
        /// <para>This may change in the future though. See TODO.</para>
        /// <para>A new uiSlider instance.</para>
        /// <para>complain or disallow min&gt;max?</para>
        /// </remarks>
        public static libui.UiSlider UiNewSlider(int32 min, int32 max)
        {
            var ___ret = __Internal.UiNewSlider(min, max);
            var __result0 = libui.UiSlider.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Returns the progress bar value.</summary>
        /// <param name="p">uiProgressBar instance.</param>
        /// <remarks>Progress bar value. `[Default 0]`</remarks>
        public static int32 UiProgressBarValue(libui.UiProgressBar p)
        {
            var __arg0 = p == null ? null : p.__Instance;
            var ___ret = __Internal.UiProgressBarValue(__arg0);
            return ___ret;
        }

        /// <summary>Sets the progress bar value.</summary>
        /// <param name="p">uiProgressBar instance.</param>
        /// <param name="n">Value to set. Integer in the range of `[-1, 100]`.</param>
        /// <remarks>
        /// <para>Valid values are `[0, 100]` for displaying a solid bar imitating a percent</para>
        /// <para>value.</para>
        /// <para>Use a value of `-1` to render an animated bar to convey an indeterminate</para>
        /// <para>value.</para>
        /// </remarks>
        public static void UiProgressBarSetValue(libui.UiProgressBar p, int32 n)
        {
            var __arg0 = p == null ? null : p.__Instance;
            __Internal.UiProgressBarSetValue(__arg0, n);
        }

        /// <summary>Creates a new progress bar.</summary>
        /// <remarks>A new uiProgressBar instance.</remarks>
        public static libui.UiProgressBar UiNewProgressBar()
        {
            var ___ret = __Internal.UiNewProgressBar();
            var __result0 = libui.UiProgressBar.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Creates a new horizontal separator to separate controls being stacked vertically.</summary>
        /// <remarks>A new uiSeparator instance.</remarks>
        public static libui.UiSeparator UiNewHorizontalSeparator()
        {
            var ___ret = __Internal.UiNewHorizontalSeparator();
            var __result0 = libui.UiSeparator.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Creates a new vertical separator to separate controls being stacked horizontally.</summary>
        /// <remarks>A new uiSeparator instance.</remarks>
        public static libui.UiSeparator UiNewVerticalSeparator()
        {
            var ___ret = __Internal.UiNewVerticalSeparator();
            var __result0 = libui.UiSeparator.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Appends an item to the combo box.</summary>
        /// <param name="c">uiCombobox instance.</param>
        /// <param name="text">Item text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        public static void UiComboboxAppend(libui.UiCombobox c, char8* text)
        {
            var __arg0 = c == null ? null : c.__Instance;
            __Internal.UiComboboxAppend(__arg0, text);
        }

        /// <summary>Inserts an item atto the combo box.</summary>
        /// <param name="c">uiCombobox instance.</param>
        /// <param name="index">Index at which to insert the item.</param>
        /// <param name="text">Item text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        public static void UiComboboxInsertAt(libui.UiCombobox c, int32 index, char8* text)
        {
            var __arg0 = c == null ? null : c.__Instance;
            __Internal.UiComboboxInsertAt(__arg0, index, text);
        }

        /// <summary>Deletes an item atfrom the combo box.</summary>
        /// <param name="c">uiCombobox instance.</param>
        /// <param name="index">Index of the item to be deleted.</param>
        /// <remarks>
        /// <para>Deleting the index of the item currently selected will move the</para>
        /// <para>selection to the next item in the combo box or `-1` if no such item exists.</para>
        /// </remarks>
        public static void UiComboboxDelete(libui.UiCombobox c, int32 index)
        {
            var __arg0 = c == null ? null : c.__Instance;
            __Internal.UiComboboxDelete(__arg0, index);
        }

        /// <summary>Deletes all items from the combo box.</summary>
        /// <param name="c">uiCombobox instance.</param>
        public static void UiComboboxClear(libui.UiCombobox c)
        {
            var __arg0 = c == null ? null : c.__Instance;
            __Internal.UiComboboxClear(__arg0);
        }

        /// <summary>Returns the number of items contained within the combo box.</summary>
        /// <param name="c">uiCombobox instance.</param>
        /// <remarks>Number of items.</remarks>
        public static int32 UiComboboxNumItems(libui.UiCombobox c)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var ___ret = __Internal.UiComboboxNumItems(__arg0);
            return ___ret;
        }

        /// <summary>Returns the index of the item selected.</summary>
        /// <param name="c">uiCombobox instance.</param>
        /// <remarks>Index of the item selected, `-1` on empty selection. [Default `-1`]</remarks>
        public static int32 UiComboboxSelected(libui.UiCombobox c)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var ___ret = __Internal.UiComboboxSelected(__arg0);
            return ___ret;
        }

        /// <summary>Sets the item selected.</summary>
        /// <param name="c">uiCombobox instance.</param>
        /// <param name="index">Index of the item to be selected, `-1` to clear selection.</param>
        public static void UiComboboxSetSelected(libui.UiCombobox c, int32 index)
        {
            var __arg0 = c == null ? null : c.__Instance;
            __Internal.UiComboboxSetSelected(__arg0, index);
        }

        /// <summary>Registers a callback for when a combo box item is selected.</summary>
        /// <param name="c">uiCombobox instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that triggered the callback.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>
        /// <para>The callback is not triggered when calling uiComboboxSetSelected(),</para>
        /// <para>uiComboboxInsertAt(), uiComboboxDelete(), or uiComboboxClear().</para>
        /// <para>Only one callback can be registered at a time.</para>
        /// </remarks>
        public static void UiComboboxOnSelected(libui.UiCombobox c, libui.Delegates.Action___IntPtr___IntPtr f, __IntPtr data)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiComboboxOnSelected(__arg0, __arg1, data);
        }

        /// <summary>Creates a new combo box.</summary>
        /// <remarks>A new uiCombobox instance.</remarks>
        public static libui.UiCombobox UiNewCombobox()
        {
            var ___ret = __Internal.UiNewCombobox();
            var __result0 = libui.UiCombobox.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Appends an item to the editable combo box.</summary>
        /// <param name="c">uiEditableCombobox instance.</param>
        /// <param name="text">Item text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        public static void UiEditableComboboxAppend(libui.UiEditableCombobox c, char8* text)
        {
            var __arg0 = c == null ? null : c.__Instance;
            __Internal.UiEditableComboboxAppend(__arg0, text);
        }

        /// <summary>Returns the text of the editable combo box.</summary>
        /// <param name="c">uiEditableCombobox instance.</param>
        /// <remarks>
        /// <para>This text is either the text of one of the predefined list items or the</para>
        /// <para>text manually entered by the user.</para>
        /// <para>The editable combo box text.A `NUL` terminated UTF-8 string.Caller is responsible for freeing the data with `uiFreeText()`.</para>
        /// </remarks>
        public static char8* UiEditableComboboxText(libui.UiEditableCombobox c)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var ___ret = __Internal.UiEditableComboboxText(__arg0);
            return ___ret;
        }

        /// <summary>Sets the editable combo box text.</summary>
        /// <param name="c">uiEditableCombobox instance.</param>
        /// <param name="text">Text field text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        public static void UiEditableComboboxSetText(libui.UiEditableCombobox c, char8* text)
        {
            var __arg0 = c == null ? null : c.__Instance;
            __Internal.UiEditableComboboxSetText(__arg0, text);
        }

        /// <summary>Registers a callback for when an editable combo box item is selected or user text changed.</summary>
        /// <param name="c">uiEditableCombobox instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that triggered the callback.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>
        /// <para>The callback is not triggered when calling uiEditableComboboxSetText().</para>
        /// <para>Only one callback can be registered at a time.</para>
        /// </remarks>
        public static void UiEditableComboboxOnChanged(libui.UiEditableCombobox c, libui.Delegates.Action___IntPtr___IntPtr f, __IntPtr data)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiEditableComboboxOnChanged(__arg0, __arg1, data);
        }

        /// <summary>Creates a new editable combo box.</summary>
        /// <remarks>A new uiEditableCombobox instance.</remarks>
        public static libui.UiEditableCombobox UiNewEditableCombobox()
        {
            var ___ret = __Internal.UiNewEditableCombobox();
            var __result0 = libui.UiEditableCombobox.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Appends a radio button.</summary>
        /// <param name="r">uiRadioButtons instance.</param>
        /// <param name="text">Radio button text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        public static void UiRadioButtonsAppend(libui.UiRadioButtons r, char8* text)
        {
            var __arg0 = r == null ? null : r.__Instance;
            __Internal.UiRadioButtonsAppend(__arg0, text);
        }

        /// <summary>Returns the index of the item selected.</summary>
        /// <param name="r">uiRadioButtons instance.</param>
        /// <remarks>Index of the item selected, `-1` on empty selection.</remarks>
        public static int32 UiRadioButtonsSelected(libui.UiRadioButtons r)
        {
            var __arg0 = r == null ? null : r.__Instance;
            var ___ret = __Internal.UiRadioButtonsSelected(__arg0);
            return ___ret;
        }

        /// <summary>Sets the item selected.</summary>
        /// <param name="r">uiRadioButtons instance.</param>
        /// <param name="index">Index of the item to be selected, `-1` to clear selection.</param>
        public static void UiRadioButtonsSetSelected(libui.UiRadioButtons r, int32 index)
        {
            var __arg0 = r == null ? null : r.__Instance;
            __Internal.UiRadioButtonsSetSelected(__arg0, index);
        }

        /// <summary>Registers a callback for when radio button is selected.</summary>
        /// <param name="r">uiRadioButtons instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that triggered the callback.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>
        /// <para>The callback is not triggered when calling uiRadioButtonsSetSelected().</para>
        /// <para>Only one callback can be registered at a time.</para>
        /// </remarks>
        public static void UiRadioButtonsOnSelected(libui.UiRadioButtons r, libui.Delegates.Action___IntPtr___IntPtr f, __IntPtr data)
        {
            var __arg0 = r == null ? null : r.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiRadioButtonsOnSelected(__arg0, __arg1, data);
        }

        /// <summary>Creates a new radio buttons instance.</summary>
        /// <remarks>A new uiRadioButtons instance.</remarks>
        public static libui.UiRadioButtons UiNewRadioButtons()
        {
            var ___ret = __Internal.UiNewRadioButtons();
            var __result0 = libui.UiRadioButtons.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Returns date and time stored in the data time picker.</summary>
        /// <param name="d">uiDateTimePicker instance.</param>
        /// <param name="time">Date and/or time as local time.</param>
        /// <remarks>The `struct tm` members `tm_wday` and `tm_yday` are undefined.</remarks>
        public static void UiDateTimePickerTime(libui.UiDateTimePicker d, libui.Tm time)
        {
            var __arg0 = d == null ? null : d.__Instance;
            var __arg1 = time == null ? null : time.__Instance;
            __Internal.UiDateTimePickerTime(__arg0, __arg1);
        }

        /// <summary>Sets date and time of the data time picker.</summary>
        /// <param name="d">uiDateTimePicker instance.</param>
        /// <param name="time">Date and/or time as local time.</param>
        /// <remarks>The `struct tm` member `tm_isdst` is ignored on windows and should be set to `-1`.</remarks>
        public static void UiDateTimePickerSetTime(libui.UiDateTimePicker d, libui.Tm time)
        {
            var __arg0 = d == null ? null : d.__Instance;
            var __arg1 = time == null ? null : time.__Instance;
            __Internal.UiDateTimePickerSetTime(__arg0, __arg1);
        }

        /// <summary>Registers a callback for when the date time picker value is changed by the user.</summary>
        /// <param name="d">uiDateTimePicker instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that triggered the callback.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>
        /// <para>The callback is not triggered when calling  uiDateTimePickerSetTime().</para>
        /// <para>Only one callback can be registered at a time.</para>
        /// </remarks>
        public static void UiDateTimePickerOnChanged(libui.UiDateTimePicker d, libui.Delegates.Action___IntPtr___IntPtr f, __IntPtr data)
        {
            var __arg0 = d == null ? null : d.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiDateTimePickerOnChanged(__arg0, __arg1, data);
        }

        /// <summary>Creates a new date picker.</summary>
        /// <remarks>A new uiDateTimePicker instance.</remarks>
        public static libui.UiDateTimePicker UiNewDateTimePicker()
        {
            var ___ret = __Internal.UiNewDateTimePicker();
            var __result0 = libui.UiDateTimePicker.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Creates a new time picker.</summary>
        /// <remarks>A new uiDateTimePicker instance.</remarks>
        public static libui.UiDateTimePicker UiNewDatePicker()
        {
            var ___ret = __Internal.UiNewDatePicker();
            var __result0 = libui.UiDateTimePicker.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Creates a new date and time picker.</summary>
        /// <remarks>A new uiDateTimePicker instance.</remarks>
        public static libui.UiDateTimePicker UiNewTimePicker()
        {
            var ___ret = __Internal.UiNewTimePicker();
            var __result0 = libui.UiDateTimePicker.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Returns the multi line entry's text.</summary>
        /// <param name="e">uiMultilineEntry instance.</param>
        /// <remarks>The containing text.A `NUL` terminated UTF-8 string.Caller is responsible for freeing the data with `uiFreeText()`.</remarks>
        public static char8* UiMultilineEntryText(libui.UiMultilineEntry e)
        {
            var __arg0 = e == null ? null : e.__Instance;
            var ___ret = __Internal.UiMultilineEntryText(__arg0);
            return ___ret;
        }

        /// <summary>Sets the multi line entry's text.</summary>
        /// <param name="e">uiMultilineEntry instance.</param>
        /// <param name="text">Single/multi line text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        public static void UiMultilineEntrySetText(libui.UiMultilineEntry e, char8* text)
        {
            var __arg0 = e == null ? null : e.__Instance;
            __Internal.UiMultilineEntrySetText(__arg0, text);
        }

        /// <summary>Appends text to the multi line entry's text.</summary>
        /// <param name="e">uiMultilineEntry instance.</param>
        /// <param name="text">Text to append.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        public static void UiMultilineEntryAppend(libui.UiMultilineEntry e, char8* text)
        {
            var __arg0 = e == null ? null : e.__Instance;
            __Internal.UiMultilineEntryAppend(__arg0, text);
        }

        /// <summary>Registers a callback for when the user changes the multi line entry's text.</summary>
        /// <param name="e">uiMultilineEntry instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that initiated the callback.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>
        /// <para>The callback is not triggered when calling uiMultilineEntrySetText()</para>
        /// <para>or uiMultilineEntryAppend().</para>
        /// <para>Only one callback can be registered at a time.</para>
        /// </remarks>
        public static void UiMultilineEntryOnChanged(libui.UiMultilineEntry e, libui.Delegates.Action___IntPtr___IntPtr f, __IntPtr data)
        {
            var __arg0 = e == null ? null : e.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiMultilineEntryOnChanged(__arg0, __arg1, data);
        }

        /// <summary>Returns whether or not the multi line entry's text can be changed.</summary>
        /// <param name="e">uiMultilineEntry instance.</param>
        /// <remarks>`TRUE` if read only, `FALSE` otherwise. [Default: `FALSE`]</remarks>
        public static int32 UiMultilineEntryReadOnly(libui.UiMultilineEntry e)
        {
            var __arg0 = e == null ? null : e.__Instance;
            var ___ret = __Internal.UiMultilineEntryReadOnly(__arg0);
            return ___ret;
        }

        /// <summary>Sets whether or not the multi line entry's text is read only.</summary>
        /// <param name="e">uiMultilineEntry instance.</param>
        /// <param name="readonly">`TRUE` to make read only, `FALSE` otherwise.</param>
        public static void UiMultilineEntrySetReadOnly(libui.UiMultilineEntry e, int32 _readonly)
        {
            var __arg0 = e == null ? null : e.__Instance;
            __Internal.UiMultilineEntrySetReadOnly(__arg0, _readonly);
        }

        /// <summary>Creates a new multi line entry that visually wraps text when lines overflow.</summary>
        /// <remarks>A new uiMultilineEntry instance.</remarks>
        public static libui.UiMultilineEntry UiNewMultilineEntry()
        {
            var ___ret = __Internal.UiNewMultilineEntry();
            var __result0 = libui.UiMultilineEntry.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Creates a new multi line entry that scrolls horizontally when lines overflow.</summary>
        /// <remarks>
        /// <para>Windows does not allow for this style to be changed after creation,</para>
        /// <para>hence the two constructors.</para>
        /// <para>A new uiMultilineEntry instance.</para>
        /// </remarks>
        public static libui.UiMultilineEntry UiNewNonWrappingMultilineEntry()
        {
            var ___ret = __Internal.UiNewNonWrappingMultilineEntry();
            var __result0 = libui.UiMultilineEntry.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Enables the menu item.</summary>
        /// <param name="m">uiMenuItem instance.</param>
        public static void UiMenuItemEnable(libui.UiMenuItem m)
        {
            var __arg0 = m == null ? null : m.__Instance;
            __Internal.UiMenuItemEnable(__arg0);
        }

        /// <summary>Disables the menu item.</summary>
        /// <param name="m">uiMenuItem instance.</param>
        /// <remarks>Menu item is grayed out and user interaction is not possible.</remarks>
        public static void UiMenuItemDisable(libui.UiMenuItem m)
        {
            var __arg0 = m == null ? null : m.__Instance;
            __Internal.UiMenuItemDisable(__arg0);
        }

        /// <summary>Registers a callback for when the menu item is clicked.</summary>
        /// <param name="m">uiMenuItem instance.</param>
        /// <param name="f">
        /// <para>Callback function.Back reference to the instance that triggered the callback.Reference to the window from which the callback got triggered.\</para>
        /// <para>User data registered with the sender instance.</para>
        /// </param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>Only one callback can be registered at a time.</remarks>
        public static void UiMenuItemOnClicked(libui.UiMenuItem m, libui.Delegates.Action___IntPtr___IntPtr___IntPtr f, __IntPtr data)
        {
            var __arg0 = m == null ? null : m.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiMenuItemOnClicked(__arg0, __arg1, data);
        }

        /// <summary>Returns whether or not the menu item's checkbox is checked.</summary>
        /// <param name="m">uiMenuItem instance.</param>
        /// <remarks>
        /// <para>To be used only with items created via uiMenuAppendCheckItem().</para>
        /// <para>`TRUE` if checked, `FALSE` otherwise. [Default: `FALSE`]</para>
        /// </remarks>
        public static int32 UiMenuItemChecked(libui.UiMenuItem m)
        {
            var __arg0 = m == null ? null : m.__Instance;
            var ___ret = __Internal.UiMenuItemChecked(__arg0);
            return ___ret;
        }

        /// <summary>Sets whether or not the menu item's checkbox is checked.</summary>
        /// <param name="m">uiMenuItem instance.</param>
        /// <param name="checked">`TRUE` to check menu item checkbox, `FALSE` otherwise.</param>
        /// <remarks>To be used only with items created via uiMenuAppendCheckItem().</remarks>
        public static void UiMenuItemSetChecked(libui.UiMenuItem m, int32 _checked)
        {
            var __arg0 = m == null ? null : m.__Instance;
            __Internal.UiMenuItemSetChecked(__arg0, _checked);
        }

        /// <summary>Appends a generic menu item.</summary>
        /// <param name="m">uiMenu instance.</param>
        /// <param name="name">Menu item text.A `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <remarks>A new uiMenuItem instance.</remarks>
        public static libui.UiMenuItem UiMenuAppendItem(libui.UiMenu m, char8* name)
        {
            var __arg0 = m == null ? null : m.__Instance;
            var ___ret = __Internal.UiMenuAppendItem(__arg0, name);
            var __result0 = libui.UiMenuItem.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Appends a generic menu item with a checkbox.</summary>
        /// <param name="m">uiMenu instance.</param>
        /// <param name="name">Menu item text.A `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <remarks>A new uiMenuItem instance.</remarks>
        public static libui.UiMenuItem UiMenuAppendCheckItem(libui.UiMenu m, char8* name)
        {
            var __arg0 = m == null ? null : m.__Instance;
            var ___ret = __Internal.UiMenuAppendCheckItem(__arg0, name);
            var __result0 = libui.UiMenuItem.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Appends a new `Quit` menu item.</summary>
        /// <param name="m">uiMenu instance.</param>
        /// <remarks>
        /// <para>A new uiMenuItem instance.</para>
        /// <para>Only one such menu item may exist per application.</para>
        /// </remarks>
        public static libui.UiMenuItem UiMenuAppendQuitItem(libui.UiMenu m)
        {
            var __arg0 = m == null ? null : m.__Instance;
            var ___ret = __Internal.UiMenuAppendQuitItem(__arg0);
            var __result0 = libui.UiMenuItem.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Appends a new `Preferences` menu item.</summary>
        /// <param name="m">uiMenu instance.</param>
        /// <remarks>
        /// <para>A new uiMenuItem instance.</para>
        /// <para>Only one such menu item may exist per application.</para>
        /// </remarks>
        public static libui.UiMenuItem UiMenuAppendPreferencesItem(libui.UiMenu m)
        {
            var __arg0 = m == null ? null : m.__Instance;
            var ___ret = __Internal.UiMenuAppendPreferencesItem(__arg0);
            var __result0 = libui.UiMenuItem.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Appends a new `About` menu item.</summary>
        /// <param name="m">uiMenu instance.</param>
        /// <remarks>
        /// <para>Only one such menu item may exist per application.</para>
        /// <para>A new uiMenuItem instance.</para>
        /// </remarks>
        public static libui.UiMenuItem UiMenuAppendAboutItem(libui.UiMenu m)
        {
            var __arg0 = m == null ? null : m.__Instance;
            var ___ret = __Internal.UiMenuAppendAboutItem(__arg0);
            var __result0 = libui.UiMenuItem.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Appends a new separator.</summary>
        /// <param name="m">uiMenu instance.</param>
        public static void UiMenuAppendSeparator(libui.UiMenu m)
        {
            var __arg0 = m == null ? null : m.__Instance;
            __Internal.UiMenuAppendSeparator(__arg0);
        }

        /// <summary>Creates a new menu.</summary>
        /// <param name="name">Menu label.A `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <remarks>
        /// <para>Typical values are `File`, `Edit`, `Help`.</para>
        /// <para>A new uiMenu instance.</para>
        /// </remarks>
        public static libui.UiMenu UiNewMenu(char8* name)
        {
            var ___ret = __Internal.UiNewMenu(name);
            var __result0 = libui.UiMenu.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>File chooser dialog window to select a single file.</summary>
        /// <param name="parent">Parent window.</param>
        /// <remarks>
        /// <para>File path, `NULL` on cancel.If path is not `NULL`:TODO: clarify string encoding.</para>
        /// <para>Caller is responsible for freeing the data with `uiFreeText()`.</para>
        /// <para>File paths are separated by the underlying OS file path separator.</para>
        /// </remarks>
        public static char8* UiOpenFile(libui.UiWindow parent)
        {
            var __arg0 = parent == null ? null : parent.__Instance;
            var ___ret = __Internal.UiOpenFile(__arg0);
            return ___ret;
        }

        /// <summary>Folder chooser dialog window to select a single folder.</summary>
        /// <param name="parent">Parent window.</param>
        /// <remarks>
        /// <para>Folder path, `NULL` on cancel.If path is not `NULL`:TODO: clarify string encoding.</para>
        /// <para>Caller is responsible for freeing the data with `uiFreeText()`.</para>
        /// <para>File paths are separated by the underlying OS file path separator.</para>
        /// </remarks>
        public static char8* UiOpenFolder(libui.UiWindow parent)
        {
            var __arg0 = parent == null ? null : parent.__Instance;
            var ___ret = __Internal.UiOpenFolder(__arg0);
            return ___ret;
        }

        /// <summary>Save file dialog window.</summary>
        /// <param name="parent">Parent window.</param>
        /// <remarks>
        /// <para>The user is asked to confirm overwriting existing files, should the chosen</para>
        /// <para>file path already exist on the system.</para>
        /// <para>File path, `NULL` on cancel.If path is not `NULL`:TODO: clarify string encoding.</para>
        /// <para>Caller is responsible for freeing the data with `uiFreeText()`.</para>
        /// <para>File paths are separated by the underlying OS file path separator.</para>
        /// </remarks>
        public static char8* UiSaveFile(libui.UiWindow parent)
        {
            var __arg0 = parent == null ? null : parent.__Instance;
            var ___ret = __Internal.UiSaveFile(__arg0);
            return ___ret;
        }

        /// <summary>Message box dialog window.</summary>
        /// <param name="parent">Parent window.</param>
        /// <param name="title">Dialog window title text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <param name="description">Dialog message text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <remarks>A message box displayed in a new window indicating a common message.</remarks>
        public static void UiMsgBox(libui.UiWindow parent, char8* title, char8* description)
        {
            var __arg0 = parent == null ? null : parent.__Instance;
            __Internal.UiMsgBox(__arg0, title, description);
        }

        /// <summary>Error message box dialog window.</summary>
        /// <param name="parent">Parent window.</param>
        /// <param name="title">Dialog window title text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <param name="description">Dialog message text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <remarks>
        /// <para>A message box displayed in a new window indicating an error. On some systems</para>
        /// <para>this may invoke an accompanying sound.</para>
        /// </remarks>
        public static void UiMsgBoxError(libui.UiWindow parent, char8* title, char8* description)
        {
            var __arg0 = parent == null ? null : parent.__Instance;
            __Internal.UiMsgBoxError(__arg0, title, description);
        }

        public static void UiAreaSetSize(libui.UiArea a, int32 width, int32 height)
        {
            var __arg0 = a == null ? null : a.__Instance;
            __Internal.UiAreaSetSize(__arg0, width, height);
        }

        public static void UiAreaQueueRedrawAll(libui.UiArea a)
        {
            var __arg0 = a == null ? null : a.__Instance;
            __Internal.UiAreaQueueRedrawAll(__arg0);
        }

        public static void UiAreaScrollTo(libui.UiArea a, double x, double y, double width, double height)
        {
            var __arg0 = a == null ? null : a.__Instance;
            __Internal.UiAreaScrollTo(__arg0, x, y, width, height);
        }

        public static void UiAreaBeginUserWindowMove(libui.UiArea a)
        {
            var __arg0 = a == null ? null : a.__Instance;
            __Internal.UiAreaBeginUserWindowMove(__arg0);
        }

        public static void UiAreaBeginUserWindowResize(libui.UiArea a, uint32 edge)
        {
            var __arg0 = a == null ? null : a.__Instance;
            __Internal.UiAreaBeginUserWindowResize(__arg0, edge);
        }

        public static libui.UiArea UiNewArea(libui.UiAreaHandler ah)
        {
            var __arg0 = ah == null ? null : ah.__Instance;
            var ___ret = __Internal.UiNewArea(__arg0);
            var __result0 = libui.UiArea.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        public static libui.UiArea UiNewScrollingArea(libui.UiAreaHandler ah, int32 width, int32 height)
        {
            var __arg0 = ah == null ? null : ah.__Instance;
            var ___ret = __Internal.UiNewScrollingArea(__arg0, width, height);
            var __result0 = libui.UiArea.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        public static libui.UiDrawPath UiDrawNewPath(uint32 fillMode)
        {
            var ___ret = __Internal.UiDrawNewPath(fillMode);
            var __result0 = libui.UiDrawPath.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        public static void UiDrawFreePath(libui.UiDrawPath p)
        {
            var __arg0 = p == null ? null : p.__Instance;
            __Internal.UiDrawFreePath(__arg0);
        }

        public static void UiDrawPathNewFigure(libui.UiDrawPath p, double x, double y)
        {
            var __arg0 = p == null ? null : p.__Instance;
            __Internal.UiDrawPathNewFigure(__arg0, x, y);
        }

        public static void UiDrawPathNewFigureWithArc(libui.UiDrawPath p, double xCenter, double yCenter, double radius, double startAngle, double sweep, int32 negative)
        {
            var __arg0 = p == null ? null : p.__Instance;
            __Internal.UiDrawPathNewFigureWithArc(__arg0, xCenter, yCenter, radius, startAngle, sweep, negative);
        }

        public static void UiDrawPathLineTo(libui.UiDrawPath p, double x, double y)
        {
            var __arg0 = p == null ? null : p.__Instance;
            __Internal.UiDrawPathLineTo(__arg0, x, y);
        }

        public static void UiDrawPathArcTo(libui.UiDrawPath p, double xCenter, double yCenter, double radius, double startAngle, double sweep, int32 negative)
        {
            var __arg0 = p == null ? null : p.__Instance;
            __Internal.UiDrawPathArcTo(__arg0, xCenter, yCenter, radius, startAngle, sweep, negative);
        }

        public static void UiDrawPathBezierTo(libui.UiDrawPath p, double c1x, double c1y, double c2x, double c2y, double endX, double endY)
        {
            var __arg0 = p == null ? null : p.__Instance;
            __Internal.UiDrawPathBezierTo(__arg0, c1x, c1y, c2x, c2y, endX, endY);
        }

        public static void UiDrawPathCloseFigure(libui.UiDrawPath p)
        {
            var __arg0 = p == null ? null : p.__Instance;
            __Internal.UiDrawPathCloseFigure(__arg0);
        }

        public static void UiDrawPathAddRectangle(libui.UiDrawPath p, double x, double y, double width, double height)
        {
            var __arg0 = p == null ? null : p.__Instance;
            __Internal.UiDrawPathAddRectangle(__arg0, x, y, width, height);
        }

        public static int32 UiDrawPathEnded(libui.UiDrawPath p)
        {
            var __arg0 = p == null ? null : p.__Instance;
            var ___ret = __Internal.UiDrawPathEnded(__arg0);
            return ___ret;
        }

        public static void UiDrawPathEnd(libui.UiDrawPath p)
        {
            var __arg0 = p == null ? null : p.__Instance;
            __Internal.UiDrawPathEnd(__arg0);
        }

        public static void UiDrawStroke(libui.UiDrawContext c, libui.UiDrawPath path, libui.UiDrawBrush b, libui.UiDrawStrokeParams p)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var __arg1 = path == null ? null : path.__Instance;
            var __arg2 = b == null ? null : b.__Instance;
            var __arg3 = p == null ? null : p.__Instance;
            __Internal.UiDrawStroke(__arg0, __arg1, __arg2, __arg3);
        }

        public static void UiDrawFill(libui.UiDrawContext c, libui.UiDrawPath path, libui.UiDrawBrush b)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var __arg1 = path == null ? null : path.__Instance;
            var __arg2 = b == null ? null : b.__Instance;
            __Internal.UiDrawFill(__arg0, __arg1, __arg2);
        }

        public static void UiDrawMatrixSetIdentity(libui.UiDrawMatrix m)
        {
            var __arg0 = m == null ? null : m.__Instance;
            __Internal.UiDrawMatrixSetIdentity(__arg0);
        }

        public static void UiDrawMatrixTranslate(libui.UiDrawMatrix m, double x, double y)
        {
            var __arg0 = m == null ? null : m.__Instance;
            __Internal.UiDrawMatrixTranslate(__arg0, x, y);
        }

        public static void UiDrawMatrixScale(libui.UiDrawMatrix m, double xCenter, double yCenter, double x, double y)
        {
            var __arg0 = m == null ? null : m.__Instance;
            __Internal.UiDrawMatrixScale(__arg0, xCenter, yCenter, x, y);
        }

        public static void UiDrawMatrixRotate(libui.UiDrawMatrix m, double x, double y, double amount)
        {
            var __arg0 = m == null ? null : m.__Instance;
            __Internal.UiDrawMatrixRotate(__arg0, x, y, amount);
        }

        public static void UiDrawMatrixSkew(libui.UiDrawMatrix m, double x, double y, double xamount, double yamount)
        {
            var __arg0 = m == null ? null : m.__Instance;
            __Internal.UiDrawMatrixSkew(__arg0, x, y, xamount, yamount);
        }

        public static void UiDrawMatrixMultiply(libui.UiDrawMatrix dest, libui.UiDrawMatrix src)
        {
            var __arg0 = dest == null ? null : dest.__Instance;
            var __arg1 = src == null ? null : src.__Instance;
            __Internal.UiDrawMatrixMultiply(__arg0, __arg1);
        }

        public static int32 UiDrawMatrixInvertible(libui.UiDrawMatrix m)
        {
            var __arg0 = m == null ? null : m.__Instance;
            var ___ret = __Internal.UiDrawMatrixInvertible(__arg0);
            return ___ret;
        }

        public static int32 UiDrawMatrixInvert(libui.UiDrawMatrix m)
        {
            var __arg0 = m == null ? null : m.__Instance;
            var ___ret = __Internal.UiDrawMatrixInvert(__arg0);
            return ___ret;
        }

        public static void UiDrawMatrixTransformPoint(libui.UiDrawMatrix m, ref double x, ref double y)
        {
            var __arg0 = m == null ? null : m.__Instance;
            double* __x1 = &x;
            {
                var __arg1 = __x1;
                double* __y2 = &y;
                {
                    var __arg2 = __y2;
                    __Internal.UiDrawMatrixTransformPoint(__arg0, __arg1, __arg2);
                }
            }
        }

        public static void UiDrawMatrixTransformSize(libui.UiDrawMatrix m, ref double x, ref double y)
        {
            var __arg0 = m == null ? null : m.__Instance;
            double* __x1 = &x;
            {
                var __arg1 = __x1;
                double* __y2 = &y;
                {
                    var __arg2 = __y2;
                    __Internal.UiDrawMatrixTransformSize(__arg0, __arg1, __arg2);
                }
            }
        }

        public static void UiDrawTransform(libui.UiDrawContext c, libui.UiDrawMatrix m)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var __arg1 = m == null ? null : m.__Instance;
            __Internal.UiDrawTransform(__arg0, __arg1);
        }

        public static void UiDrawClip(libui.UiDrawContext c, libui.UiDrawPath path)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var __arg1 = path == null ? null : path.__Instance;
            __Internal.UiDrawClip(__arg0, __arg1);
        }

        public static void UiDrawSave(libui.UiDrawContext c)
        {
            var __arg0 = c == null ? null : c.__Instance;
            __Internal.UiDrawSave(__arg0);
        }

        public static void UiDrawRestore(libui.UiDrawContext c)
        {
            var __arg0 = c == null ? null : c.__Instance;
            __Internal.UiDrawRestore(__arg0);
        }

        public static void UiFreeAttribute(libui.UiAttribute a)
        {
            var __arg0 = a == null ? null : a.__Instance;
            __Internal.UiFreeAttribute(__arg0);
        }

        public static uint32 UiAttributeGetType(libui.UiAttribute a)
        {
            var __arg0 = a == null ? null : a.__Instance;
            var ___ret = __Internal.UiAttributeGetType(__arg0);
            return ___ret;
        }

        public static libui.UiAttribute UiNewFamilyAttribute(char8* family)
        {
            var ___ret = __Internal.UiNewFamilyAttribute(family);
            var __result0 = libui.UiAttribute.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        public static char8* UiAttributeFamily(libui.UiAttribute a)
        {
            var __arg0 = a == null ? null : a.__Instance;
            var ___ret = __Internal.UiAttributeFamily(__arg0);
            return ___ret;
        }

        public static libui.UiAttribute UiNewSizeAttribute(double size)
        {
            var ___ret = __Internal.UiNewSizeAttribute(size);
            var __result0 = libui.UiAttribute.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        public static double UiAttributeSize(libui.UiAttribute a)
        {
            var __arg0 = a == null ? null : a.__Instance;
            var ___ret = __Internal.UiAttributeSize(__arg0);
            return ___ret;
        }

        public static libui.UiAttribute UiNewWeightAttribute(uint32 weight)
        {
            var ___ret = __Internal.UiNewWeightAttribute(weight);
            var __result0 = libui.UiAttribute.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        public static uint32 UiAttributeWeight(libui.UiAttribute a)
        {
            var __arg0 = a == null ? null : a.__Instance;
            var ___ret = __Internal.UiAttributeWeight(__arg0);
            return ___ret;
        }

        public static libui.UiAttribute UiNewItalicAttribute(uint32 italic)
        {
            var ___ret = __Internal.UiNewItalicAttribute(italic);
            var __result0 = libui.UiAttribute.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        public static uint32 UiAttributeItalic(libui.UiAttribute a)
        {
            var __arg0 = a == null ? null : a.__Instance;
            var ___ret = __Internal.UiAttributeItalic(__arg0);
            return ___ret;
        }

        public static libui.UiAttribute UiNewStretchAttribute(uint32 stretch)
        {
            var ___ret = __Internal.UiNewStretchAttribute(stretch);
            var __result0 = libui.UiAttribute.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        public static uint32 UiAttributeStretch(libui.UiAttribute a)
        {
            var __arg0 = a == null ? null : a.__Instance;
            var ___ret = __Internal.UiAttributeStretch(__arg0);
            return ___ret;
        }

        public static libui.UiAttribute UiNewColorAttribute(double r, double g, double b, double a)
        {
            var ___ret = __Internal.UiNewColorAttribute(r, g, b, a);
            var __result0 = libui.UiAttribute.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        public static void UiAttributeColor(libui.UiAttribute a, ref double r, ref double g, ref double b, ref double alpha)
        {
            var __arg0 = a == null ? null : a.__Instance;
            double* __r1 = &r;
            {
                var __arg1 = __r1;
                double* __g2 = &g;
                {
                    var __arg2 = __g2;
                    double* __b3 = &b;
                    {
                        var __arg3 = __b3;
                        double* __alpha4 = &alpha;
                        {
                            var __arg4 = __alpha4;
                            __Internal.UiAttributeColor(__arg0, __arg1, __arg2, __arg3, __arg4);
                        }
                    }
                }
            }
        }

        public static libui.UiAttribute UiNewBackgroundAttribute(double r, double g, double b, double a)
        {
            var ___ret = __Internal.UiNewBackgroundAttribute(r, g, b, a);
            var __result0 = libui.UiAttribute.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        public static libui.UiAttribute UiNewUnderlineAttribute(uint32 u)
        {
            var ___ret = __Internal.UiNewUnderlineAttribute(u);
            var __result0 = libui.UiAttribute.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        public static uint32 UiAttributeUnderline(libui.UiAttribute a)
        {
            var __arg0 = a == null ? null : a.__Instance;
            var ___ret = __Internal.UiAttributeUnderline(__arg0);
            return ___ret;
        }

        public static libui.UiAttribute UiNewUnderlineColorAttribute(uint32 u, double r, double g, double b, double a)
        {
            var ___ret = __Internal.UiNewUnderlineColorAttribute(u, r, g, b, a);
            var __result0 = libui.UiAttribute.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        public static void UiAttributeUnderlineColor(libui.UiAttribute a, ref uint32 u, ref double r, ref double g, ref double b, ref double alpha)
        {
            var __arg0 = a == null ? null : a.__Instance;
            uint32* __u1 = &u;
            {
                var __arg1 = __u1;
                double* __r2 = &r;
                {
                    var __arg2 = __r2;
                    double* __g3 = &g;
                    {
                        var __arg3 = __g3;
                        double* __b4 = &b;
                        {
                            var __arg4 = __b4;
                            double* __alpha5 = &alpha;
                            {
                                var __arg5 = __alpha5;
                                __Internal.UiAttributeUnderlineColor(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);
                            }
                        }
                    }
                }
            }
        }

        public static libui.UiOpenTypeFeatures UiNewOpenTypeFeatures()
        {
            var ___ret = __Internal.UiNewOpenTypeFeatures();
            var __result0 = libui.UiOpenTypeFeatures.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        public static void UiFreeOpenTypeFeatures(libui.UiOpenTypeFeatures otf)
        {
            var __arg0 = otf == null ? null : otf.__Instance;
            __Internal.UiFreeOpenTypeFeatures(__arg0);
        }

        public static libui.UiOpenTypeFeatures UiOpenTypeFeaturesClone(libui.UiOpenTypeFeatures otf)
        {
            var __arg0 = otf == null ? null : otf.__Instance;
            var ___ret = __Internal.UiOpenTypeFeaturesClone(__arg0);
            var __result0 = libui.UiOpenTypeFeatures.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        public static void UiOpenTypeFeaturesAdd(libui.UiOpenTypeFeatures otf, int8 a, int8 b, int8 c, int8 d, uint32 value)
        {
            var __arg0 = otf == null ? null : otf.__Instance;
            __Internal.UiOpenTypeFeaturesAdd(__arg0, a, b, c, d, value);
        }

        public static void UiOpenTypeFeaturesRemove(libui.UiOpenTypeFeatures otf, int8 a, int8 b, int8 c, int8 d)
        {
            var __arg0 = otf == null ? null : otf.__Instance;
            __Internal.UiOpenTypeFeaturesRemove(__arg0, a, b, c, d);
        }

        public static int32 UiOpenTypeFeaturesGet(libui.UiOpenTypeFeatures otf, int8 a, int8 b, int8 c, int8 d, ref uint32 value)
        {
            var __arg0 = otf == null ? null : otf.__Instance;
            uint32* __value5 = &value;
            {
                var __arg5 = __value5;
                var ___ret = __Internal.UiOpenTypeFeaturesGet(__arg0, a, b, c, d, __arg5);
                return ___ret;
            }
        }

        public static void UiOpenTypeFeaturesForEach(libui.UiOpenTypeFeatures otf, libui.UiOpenTypeFeaturesForEachFunc f, __IntPtr data)
        {
            var __arg0 = otf == null ? null : otf.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiOpenTypeFeaturesForEach(__arg0, __arg1, data);
        }

        public static libui.UiAttribute UiNewFeaturesAttribute(libui.UiOpenTypeFeatures otf)
        {
            var __arg0 = otf == null ? null : otf.__Instance;
            var ___ret = __Internal.UiNewFeaturesAttribute(__arg0);
            var __result0 = libui.UiAttribute.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        public static libui.UiOpenTypeFeatures UiAttributeFeatures(libui.UiAttribute a)
        {
            var __arg0 = a == null ? null : a.__Instance;
            var ___ret = __Internal.UiAttributeFeatures(__arg0);
            var __result0 = libui.UiOpenTypeFeatures.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        public static libui.UiAttributedString UiNewAttributedString(char8* initialString)
        {
            var ___ret = __Internal.UiNewAttributedString(initialString);
            var __result0 = libui.UiAttributedString.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        public static void UiFreeAttributedString(libui.UiAttributedString s)
        {
            var __arg0 = s == null ? null : s.__Instance;
            __Internal.UiFreeAttributedString(__arg0);
        }

        public static char8* UiAttributedStringString(libui.UiAttributedString s)
        {
            var __arg0 = s == null ? null : s.__Instance;
            var ___ret = __Internal.UiAttributedStringString(__arg0);
            return ___ret;
        }

        public static uint64 UiAttributedStringLen(libui.UiAttributedString s)
        {
            var __arg0 = s == null ? null : s.__Instance;
            var ___ret = __Internal.UiAttributedStringLen(__arg0);
            return ___ret;
        }

        public static void UiAttributedStringAppendUnattributed(libui.UiAttributedString s, char8* str)
        {
            var __arg0 = s == null ? null : s.__Instance;
            __Internal.UiAttributedStringAppendUnattributed(__arg0, str);
        }

        public static void UiAttributedStringInsertAtUnattributed(libui.UiAttributedString s, char8* str, uint64 at)
        {
            var __arg0 = s == null ? null : s.__Instance;
            __Internal.UiAttributedStringInsertAtUnattributed(__arg0, str, at);
        }

        public static void UiAttributedStringDelete(libui.UiAttributedString s, uint64 start, uint64 end)
        {
            var __arg0 = s == null ? null : s.__Instance;
            __Internal.UiAttributedStringDelete(__arg0, start, end);
        }

        public static void UiAttributedStringSetAttribute(libui.UiAttributedString s, libui.UiAttribute a, uint64 start, uint64 end)
        {
            var __arg0 = s == null ? null : s.__Instance;
            var __arg1 = a == null ? null : a.__Instance;
            __Internal.UiAttributedStringSetAttribute(__arg0, __arg1, start, end);
        }

        public static void UiAttributedStringForEachAttribute(libui.UiAttributedString s, libui.UiAttributedStringForEachAttributeFunc f, __IntPtr data)
        {
            var __arg0 = s == null ? null : s.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiAttributedStringForEachAttribute(__arg0, __arg1, data);
        }

        public static uint64 UiAttributedStringNumGraphemes(libui.UiAttributedString s)
        {
            var __arg0 = s == null ? null : s.__Instance;
            var ___ret = __Internal.UiAttributedStringNumGraphemes(__arg0);
            return ___ret;
        }

        public static uint64 UiAttributedStringByteIndexToGrapheme(libui.UiAttributedString s, uint64 pos)
        {
            var __arg0 = s == null ? null : s.__Instance;
            var ___ret = __Internal.UiAttributedStringByteIndexToGrapheme(__arg0, pos);
            return ___ret;
        }

        public static uint64 UiAttributedStringGraphemeToByteIndex(libui.UiAttributedString s, uint64 pos)
        {
            var __arg0 = s == null ? null : s.__Instance;
            var ___ret = __Internal.UiAttributedStringGraphemeToByteIndex(__arg0, pos);
            return ___ret;
        }

        public static void UiLoadControlFont(libui.UiFontDescriptor f)
        {
            var __arg0 = f == null ? null : f.__Instance;
            __Internal.UiLoadControlFont(__arg0);
        }

        public static void UiFreeFontDescriptor(libui.UiFontDescriptor desc)
        {
            var __arg0 = desc == null ? null : desc.__Instance;
            __Internal.UiFreeFontDescriptor(__arg0);
        }

        public static libui.UiDrawTextLayout UiDrawNewTextLayout(libui.UiDrawTextLayoutParams _params)
        {
            var __arg0 = _params == null ? null : _params.__Instance;
            var ___ret = __Internal.UiDrawNewTextLayout(__arg0);
            var __result0 = libui.UiDrawTextLayout.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        public static void UiDrawFreeTextLayout(libui.UiDrawTextLayout tl)
        {
            var __arg0 = tl == null ? null : tl.__Instance;
            __Internal.UiDrawFreeTextLayout(__arg0);
        }

        public static void UiDrawText(libui.UiDrawContext c, libui.UiDrawTextLayout tl, double x, double y)
        {
            var __arg0 = c == null ? null : c.__Instance;
            var __arg1 = tl == null ? null : tl.__Instance;
            __Internal.UiDrawText(__arg0, __arg1, x, y);
        }

        public static void UiDrawTextLayoutExtents(libui.UiDrawTextLayout tl, ref double width, ref double height)
        {
            var __arg0 = tl == null ? null : tl.__Instance;
            double* __width1 = &width;
            {
                var __arg1 = __width1;
                double* __height2 = &height;
                {
                    var __arg2 = __height2;
                    __Internal.UiDrawTextLayoutExtents(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Returns the selected font.</summary>
        /// <param name="b">uiFontButton instance.</param>
        /// <param name="desc">Font descriptor. [Default: OS-dependent].</param>
        /// <remarks>
        /// <para>Make sure to call `uiFreeFontButtonFont()` to free all allocated</para>
        /// <para>resources within</para>
        /// </remarks>
        public static void UiFontButtonFont(libui.UiFontButton b, libui.UiFontDescriptor desc)
        {
            var __arg0 = b == null ? null : b.__Instance;
            var __arg1 = desc == null ? null : desc.__Instance;
            __Internal.UiFontButtonFont(__arg0, __arg1);
        }

        /// <summary>Registers a callback for when the font is changed.</summary>
        /// <param name="b">uiFontButton instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that triggered the callback.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>Only one callback can be registered at a time.</remarks>
        public static void UiFontButtonOnChanged(libui.UiFontButton b, libui.Delegates.Action___IntPtr___IntPtr f, __IntPtr data)
        {
            var __arg0 = b == null ? null : b.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiFontButtonOnChanged(__arg0, __arg1, data);
        }

        /// <summary>Creates a new font button.</summary>
        /// <remarks>
        /// <para>The default font is determined by the OS defaults.</para>
        /// <para>A new uiFontButton instance.</para>
        /// </remarks>
        public static libui.UiFontButton UiNewFontButton()
        {
            var ___ret = __Internal.UiNewFontButton();
            var __result0 = libui.UiFontButton.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Frees a uiFontDescriptor previously filled by uiFontButtonFont().</summary>
        /// <param name="desc">Font descriptor to free.</param>
        /// <remarks>
        /// <para>After calling this function the contents ofshould be assumed undefined,</para>
        /// <para>however you can safely reuse</para>
        /// <para>Calling this function on a uiFontDescriptor not previously filled by</para>
        /// <para>uiFontButtonFont() results in undefined behavior.</para>
        /// </remarks>
        public static void UiFreeFontButtonFont(libui.UiFontDescriptor desc)
        {
            var __arg0 = desc == null ? null : desc.__Instance;
            __Internal.UiFreeFontButtonFont(__arg0);
        }

        /// <summary>Returns the color button color.</summary>
        /// <param name="b">uiColorButton instance.</param>
        /// <param name="r">Red. Double in range of [0, 1.0].</param>
        /// <param name="g">Green. Double in range of [0, 1.0].</param>
        /// <param name="bl">Blue. Double in range of [0, 1.0].</param>
        /// <param name="a">Alpha. Double in range of [0, 1.0].</param>
        public static void UiColorButtonColor(libui.UiColorButton b, ref double r, ref double g, ref double bl, ref double a)
        {
            var __arg0 = b == null ? null : b.__Instance;
            double* __r1 = &r;
            {
                var __arg1 = __r1;
                double* __g2 = &g;
                {
                    var __arg2 = __g2;
                    double* __bl3 = &bl;
                    {
                        var __arg3 = __bl3;
                        double* __a4 = &a;
                        {
                            var __arg4 = __a4;
                            __Internal.UiColorButtonColor(__arg0, __arg1, __arg2, __arg3, __arg4);
                        }
                    }
                }
            }
        }

        /// <summary>Sets the color button color.</summary>
        /// <param name="b">uiColorButton instance.</param>
        /// <param name="r">Red. Double in range of [0, 1.0].</param>
        /// <param name="g">Green. Double in range of [0, 1.0].</param>
        /// <param name="bl">Blue. Double in range of [0, 1.0].</param>
        /// <param name="a">Alpha. Double in range of [0, 1.0].</param>
        public static void UiColorButtonSetColor(libui.UiColorButton b, double r, double g, double bl, double a)
        {
            var __arg0 = b == null ? null : b.__Instance;
            __Internal.UiColorButtonSetColor(__arg0, r, g, bl, a);
        }

        /// <summary>Registers a callback for when the color is changed.</summary>
        /// <param name="b">uiColorButton instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that triggered the callback.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>
        /// <para>The callback is not triggered when calling uiColorButtonSetColor().</para>
        /// <para>Only one callback can be registered at a time.</para>
        /// </remarks>
        public static void UiColorButtonOnChanged(libui.UiColorButton b, libui.Delegates.Action___IntPtr___IntPtr f, __IntPtr data)
        {
            var __arg0 = b == null ? null : b.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiColorButtonOnChanged(__arg0, __arg1, data);
        }

        /// <summary>Creates a new color button.</summary>
        /// <remarks>A new uiColorButton instance.</remarks>
        public static libui.UiColorButton UiNewColorButton()
        {
            var ___ret = __Internal.UiNewColorButton();
            var __result0 = libui.UiColorButton.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Appends a control with a label to the form.</summary>
        /// <param name="f">uiForm instance.</param>
        /// <param name="label">Label text.A `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <param name="c">Control to append.</param>
        /// <param name="stretchy">`TRUE` to stretch control, `FALSE` otherwise.</param>
        /// <remarks>
        /// <para>Stretchy items expand to use the remaining space within the container.</para>
        /// <para>In the case of multiple stretchy items the space is shared equally.</para>
        /// </remarks>
        public static void UiFormAppend(libui.UiForm f, char8* label, libui.UiControl c, int32 stretchy)
        {
            var __arg0 = f == null ? null : f.__Instance;
            var __arg2 = c == null ? null : c.__Instance;
            __Internal.UiFormAppend(__arg0, label, __arg2, stretchy);
        }

        /// <summary>Returns the number of controls contained within the form.</summary>
        /// <param name="f">uiForm instance.</param>
        public static int32 UiFormNumChildren(libui.UiForm f)
        {
            var __arg0 = f == null ? null : f.__Instance;
            var ___ret = __Internal.UiFormNumChildren(__arg0);
            return ___ret;
        }

        /// <summary>Removes the control atfrom the form.</summary>
        /// <param name="f">uiForm instance.</param>
        /// <param name="index">Index of the control to be removed.</param>
        /// <remarks>The control is neither destroyed nor freed.</remarks>
        public static void UiFormDelete(libui.UiForm f, int32 index)
        {
            var __arg0 = f == null ? null : f.__Instance;
            __Internal.UiFormDelete(__arg0, index);
        }

        /// <summary>Returns whether or not controls within the form are padded.</summary>
        /// <param name="f">uiForm instance.</param>
        /// <remarks>
        /// <para>Padding is defined as space between individual controls.</para>
        /// <para>`TRUE` if controls are padded, `FALSE` otherwise. [Default: `TODO`]</para>
        /// </remarks>
        public static int32 UiFormPadded(libui.UiForm f)
        {
            var __arg0 = f == null ? null : f.__Instance;
            var ___ret = __Internal.UiFormPadded(__arg0);
            return ___ret;
        }

        /// <summary>Sets whether or not controls within the box are padded.</summary>
        /// <param name="f">uiForm instance.</param>
        /// <param name="padded">`TRUE` to make controls padded, `FALSE` otherwise.</param>
        /// <remarks>
        /// <para>Padding is defined as space between individual controls.</para>
        /// <para>The padding size is determined by the OS defaults.</para>
        /// </remarks>
        public static void UiFormSetPadded(libui.UiForm f, int32 padded)
        {
            var __arg0 = f == null ? null : f.__Instance;
            __Internal.UiFormSetPadded(__arg0, padded);
        }

        /// <summary>Creates a new form.</summary>
        /// <remarks>A new uiForm instance.</remarks>
        public static libui.UiForm UiNewForm()
        {
            var ___ret = __Internal.UiNewForm();
            var __result0 = libui.UiForm.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Appends a control to the grid.</summary>
        /// <param name="g">uiGrid instance.</param>
        /// <param name="c">The control to insert.</param>
        /// <param name="left">Placement as number of columns from the left. Integer in range of `[INT_MIN, INT_MAX]`.</param>
        /// <param name="top">Placement as number of rows from the top. Integer in range of `[INT_MIN, INT_MAX]`.</param>
        /// <param name="xspan">Number of columns to span. Integer in range of `[0, INT_MAX]`.</param>
        /// <param name="yspan">Number of rows to span. Integer in range of `[0, INT_MAX]`.</param>
        /// <param name="hexpand">`TRUE` to expand reserved area horizontally, `FALSE` otherwise.</param>
        /// <param name="halign">Horizontal alignment of the control within the reserved space.</param>
        /// <param name="vexpand">`TRUE` to expand reserved area vertically, `FALSE` otherwise.</param>
        /// <param name="valign">Vertical alignment of the control within the reserved space.</param>
        public static void UiGridAppend(libui.UiGrid g, libui.UiControl c, int32 left, int32 top, int32 xspan, int32 yspan, int32 hexpand, uint32 halign, int32 vexpand, uint32 valign)
        {
            var __arg0 = g == null ? null : g.__Instance;
            var __arg1 = c == null ? null : c.__Instance;
            __Internal.UiGridAppend(__arg0, __arg1, left, top, xspan, yspan, hexpand, halign, vexpand, valign);
        }

        /// <summary>Inserts a control positioned in relation to another control within the grid.</summary>
        /// <param name="g">uiGrid instance.</param>
        /// <param name="c">The control to insert.</param>
        /// <param name="existing">The existing control to position relatively to.</param>
        /// <param name="at">Placement specifier in relation tocontrol.</param>
        /// <param name="xspan">Number of columns to span. Integer in range of `[0, INT_MAX]`.</param>
        /// <param name="yspan">Number of rows to span. Integer in range of `[0, INT_MAX]`.</param>
        /// <param name="hexpand">`TRUE` to expand reserved area horizontally, `FALSE` otherwise.</param>
        /// <param name="halign">Horizontal alignment of the control within the reserved space.</param>
        /// <param name="vexpand">`TRUE` to expand reserved area vertically, `FALSE` otherwise.</param>
        /// <param name="valign">Vertical alignment of the control within the reserved space.</param>
        public static void UiGridInsertAt(libui.UiGrid g, libui.UiControl c, libui.UiControl existing, uint32 at, int32 xspan, int32 yspan, int32 hexpand, uint32 halign, int32 vexpand, uint32 valign)
        {
            var __arg0 = g == null ? null : g.__Instance;
            var __arg1 = c == null ? null : c.__Instance;
            var __arg2 = existing == null ? null : existing.__Instance;
            __Internal.UiGridInsertAt(__arg0, __arg1, __arg2, at, xspan, yspan, hexpand, halign, vexpand, valign);
        }

        /// <summary>Returns whether or not controls within the grid are padded.</summary>
        /// <param name="g">uiGrid instance.</param>
        /// <remarks>
        /// <para>Padding is defined as space between individual controls.</para>
        /// <para>`TRUE` if controls are padded, `FALSE` otherwise. [Default: `TODO`]</para>
        /// </remarks>
        public static int32 UiGridPadded(libui.UiGrid g)
        {
            var __arg0 = g == null ? null : g.__Instance;
            var ___ret = __Internal.UiGridPadded(__arg0);
            return ___ret;
        }

        /// <summary>Sets whether or not controls within the grid are padded.</summary>
        /// <param name="g">uiGrid instance.</param>
        /// <param name="padded">`TRUE` to make controls padded, `FALSE` otherwise.</param>
        /// <remarks>
        /// <para>Padding is defined as space between individual controls.</para>
        /// <para>The padding size is determined by the OS defaults.</para>
        /// </remarks>
        public static void UiGridSetPadded(libui.UiGrid g, int32 padded)
        {
            var __arg0 = g == null ? null : g.__Instance;
            __Internal.UiGridSetPadded(__arg0, padded);
        }

        /// <summary>Creates a new grid.</summary>
        /// <remarks>A new uiGrid instance.</remarks>
        public static libui.UiGrid UiNewGrid()
        {
            var ___ret = __Internal.UiNewGrid();
            var __result0 = libui.UiGrid.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Creates a new image container.</summary>
        /// <param name="width">Width in points.</param>
        /// <param name="height">Height in points.</param>
        /// <remarks>
        /// <para>Dimensions are measured in points. This is most commonly the pixel size</para>
        /// <para>of the `1x` scaled image.</para>
        /// <para>A new uiImage instance.</para>
        /// </remarks>
        public static libui.UiImage UiNewImage(double width, double height)
        {
            var ___ret = __Internal.UiNewImage(width, height);
            var __result0 = libui.UiImage.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Frees the image container and all associated resources.</summary>
        /// <param name="i">uiImage instance.</param>
        public static void UiFreeImage(libui.UiImage i)
        {
            var __arg0 = i == null ? null : i.__Instance;
            __Internal.UiFreeImage(__arg0);
        }

        /// <summary>Appends a new image representation.</summary>
        /// <param name="i">uiImage instance.</param>
        /// <param name="pixels">
        /// <para>Byte array of premultiplied pixels in [R G B A] order.`((uint8_t *) pixels)[0]` equals the **R** of the first pixel,</para>
        /// <para>`[3]` the **A** of the first pixel.`pixels` must be at least `byteStride * pixelHeight` bytes long.Data is copied internally. Ownership is not transferred.</para>
        /// </param>
        /// <param name="pixelWidth">Width in pixels.</param>
        /// <param name="pixelHeight">Height in pixels.</param>
        /// <param name="byteStride">Number of bytes per row of the pixel array.</param>
        /// <remarks>
        /// <para>see if we either need the stride or can provide a way to get the OS-preferred stride (in cairo we do)</para>
        /// <para>use const void * for const correctness</para>
        /// </remarks>
        public static void UiImageAppend(libui.UiImage i, __IntPtr pixels, int32 pixelWidth, int32 pixelHeight, int32 byteStride)
        {
            var __arg0 = i == null ? null : i.__Instance;
            __Internal.UiImageAppend(__arg0, pixels, pixelWidth, pixelHeight, byteStride);
        }

        /// <summary>Frees the uiTableValue.</summary>
        /// <param name="v">Table value to free.</param>
        /// <remarks>
        /// <para>This function is to be used only on uiTableValue objects that</para>
        /// <para>have NOT been passed to uiTable or uiTableModel - as these</para>
        /// <para>take ownership of the object.Use this for freeing erroneously created values or when directly</para>
        /// <para>calling uiTableModelHandler without transferring ownership to</para>
        /// <para>uiTable or uiTableModel.</para>
        /// </remarks>
        public static void UiFreeTableValue(libui.UiTableValue v)
        {
            var __arg0 = v == null ? null : v.__Instance;
            __Internal.UiFreeTableValue(__arg0);
        }

        /// <summary>Gets the uiTableValue type.</summary>
        /// <param name="v">Table value.</param>
        /// <remarks>Table value type.</remarks>
        public static uint32 UiTableValueGetType(libui.UiTableValue v)
        {
            var __arg0 = v == null ? null : v.__Instance;
            var ___ret = __Internal.UiTableValueGetType(__arg0);
            return ___ret;
        }

        /// <summary>Creates a new table value to store a text string.</summary>
        /// <param name="str">String value.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <remarks>A new uiTableValue instance.</remarks>
        public static libui.UiTableValue UiNewTableValueString(char8* str)
        {
            var ___ret = __Internal.UiNewTableValueString(str);
            var __result0 = libui.UiTableValue.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Returns the string value held internally.</summary>
        /// <param name="v">Table value.</param>
        /// <remarks>
        /// <para>To be used only on uiTableValue objects of type uiTableValueTypeString.</para>
        /// <para>String value.A `NUL` terminated UTF-8 string.Data remains owned bydo **NOT** call `uiFreeText()`.</para>
        /// </remarks>
        public static char8* UiTableValueString(libui.UiTableValue v)
        {
            var __arg0 = v == null ? null : v.__Instance;
            var ___ret = __Internal.UiTableValueString(__arg0);
            return ___ret;
        }

        /// <summary>Creates a new table value to store an image.</summary>
        /// <param name="img">Image.Data is NOT copied and needs to kept alive.</param>
        /// <remarks>
        /// <para>A new uiTableValue instance.</para>
        /// <para>Unlike other uiTableValue constructors, uiNewTableValueImage() does</para>
        /// <para>NOT copy the image to save time and space. Make sure the image</para>
        /// <para>data stays valid while in use by the library.</para>
        /// <para>As a general rule: if the constructor is called via the</para>
        /// <para>uiTableModelHandler, the image is safe to free once execution</para>
        /// <para>returns to ANY of your code.</para>
        /// </remarks>
        public static libui.UiTableValue UiNewTableValueImage(libui.UiImage img)
        {
            var __arg0 = img == null ? null : img.__Instance;
            var ___ret = __Internal.UiNewTableValueImage(__arg0);
            var __result0 = libui.UiTableValue.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Returns a reference to the image contained.</summary>
        /// <param name="v">Table value.</param>
        /// <remarks>
        /// <para>To be used only on uiTableValue objects of type uiTableValueTypeImage.</para>
        /// <para>Image.Data is owned by the caller of uiNewTableValueImage().</para>
        /// <para>The image returned is not owned by the objecthence no lifetime guarantees can be made.</para>
        /// </remarks>
        public static libui.UiImage UiTableValueImage(libui.UiTableValue v)
        {
            var __arg0 = v == null ? null : v.__Instance;
            var ___ret = __Internal.UiTableValueImage(__arg0);
            var __result0 = libui.UiImage.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Creates a new table value to store an integer.</summary>
        /// <param name="i">Integer value.</param>
        /// <remarks>
        /// <para>This value type can be used in conjunction with properties like</para>
        /// <para>column editable [`TRUE`, `FALSE`] or controls like progress bars and</para>
        /// <para>checkboxes. For these, consult uiProgressBar and uiCheckbox for the allowed</para>
        /// <para>integer ranges.</para>
        /// <para>A new uiTableValue instance.</para>
        /// </remarks>
        public static libui.UiTableValue UiNewTableValueInt(int32 i)
        {
            var ___ret = __Internal.UiNewTableValueInt(i);
            var __result0 = libui.UiTableValue.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Returns the integer value held internally.</summary>
        /// <param name="v">Table value.</param>
        /// <remarks>
        /// <para>To be used only on uiTableValue objects of type uiTableValueTypeInt.</para>
        /// <para>Integer value.</para>
        /// </remarks>
        public static int32 UiTableValueInt(libui.UiTableValue v)
        {
            var __arg0 = v == null ? null : v.__Instance;
            var ___ret = __Internal.UiTableValueInt(__arg0);
            return ___ret;
        }

        /// <summary>Creates a new table value to store a color in.</summary>
        /// <param name="r">Red. Double in range of [0, 1.0].</param>
        /// <param name="g">Green. Double in range of [0, 1.0].</param>
        /// <param name="b">Blue. Double in range of [0, 1.0].</param>
        /// <param name="a">Alpha. Double in range of [0, 1.0].</param>
        /// <remarks>A new uiTableValue instance.</remarks>
        public static libui.UiTableValue UiNewTableValueColor(double r, double g, double b, double a)
        {
            var ___ret = __Internal.UiNewTableValueColor(r, g, b, a);
            var __result0 = libui.UiTableValue.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Returns the color value held internally.</summary>
        /// <param name="v">Table value.</param>
        /// <param name="r">Red. Double in range of [0, 1.0].</param>
        /// <param name="g">Green. Double in range of [0, 1.0].</param>
        /// <param name="b">Blue. Double in range of [0, 1.0].</param>
        /// <param name="a">Alpha. Double in range of [0, 1.0].</param>
        /// <remarks>To be used only on uiTableValue objects of type uiTableValueTypeColor.</remarks>
        public static void UiTableValueColor(libui.UiTableValue v, ref double r, ref double g, ref double b, ref double a)
        {
            var __arg0 = v == null ? null : v.__Instance;
            double* __r1 = &r;
            {
                var __arg1 = __r1;
                double* __g2 = &g;
                {
                    var __arg2 = __g2;
                    double* __b3 = &b;
                    {
                        var __arg3 = __b3;
                        double* __a4 = &a;
                        {
                            var __arg4 = __a4;
                            __Internal.UiTableValueColor(__arg0, __arg1, __arg2, __arg3, __arg4);
                        }
                    }
                }
            }
        }

        /// <summary>Creates a new table model.</summary>
        /// <param name="mh">Table model handler.</param>
        /// <remarks>A new uiTableModel instance.</remarks>
        public static libui.UiTableModel UiNewTableModel(libui.UiTableModelHandler mh)
        {
            var __arg0 = mh == null ? null : mh.__Instance;
            var ___ret = __Internal.UiNewTableModel(__arg0);
            var __result0 = libui.UiTableModel.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Frees the table model.</summary>
        /// <param name="m">Table model to free.</param>
        /// <remarks>
        /// <para>It is an error to free table models currently associated with a</para>
        /// <para>uiTable.</para>
        /// </remarks>
        public static void UiFreeTableModel(libui.UiTableModel m)
        {
            var __arg0 = m == null ? null : m.__Instance;
            __Internal.UiFreeTableModel(__arg0);
        }

        /// <summary>Informs all associated uiTable views that a new row has been added.</summary>
        /// <param name="m">Table model that has changed.</param>
        /// <param name="newIndex">Index of the row that has been added.</param>
        /// <remarks>
        /// <para>You must insert the row data in your model before calling this function.</para>
        /// <para>NumRows() must represent the new row count before you call this function.</para>
        /// </remarks>
        public static void UiTableModelRowInserted(libui.UiTableModel m, int32 newIndex)
        {
            var __arg0 = m == null ? null : m.__Instance;
            __Internal.UiTableModelRowInserted(__arg0, newIndex);
        }

        /// <summary>Informs all associated uiTable views that a row has been changed.</summary>
        /// <param name="m">Table model that has changed.</param>
        /// <param name="index">Index of the row that has changed.</param>
        /// <remarks>
        /// <para>You do NOT need to call this in your SetCellValue() handlers, but NEED</para>
        /// <para>to call this if your data changes at any other point.</para>
        /// </remarks>
        public static void UiTableModelRowChanged(libui.UiTableModel m, int32 index)
        {
            var __arg0 = m == null ? null : m.__Instance;
            __Internal.UiTableModelRowChanged(__arg0, index);
        }

        /// <summary>Informs all associated uiTable views that a row has been deleted.</summary>
        /// <param name="m">Table model that has changed.</param>
        /// <param name="oldIndex">Index of the row that has been deleted.</param>
        /// <remarks>
        /// <para>You must delete the row from your model before you call this function.</para>
        /// <para>NumRows() must represent the new row count before you call this function.</para>
        /// </remarks>
        public static void UiTableModelRowDeleted(libui.UiTableModel m, int32 oldIndex)
        {
            var __arg0 = m == null ? null : m.__Instance;
            __Internal.UiTableModelRowDeleted(__arg0, oldIndex);
        }

        /// <summary>Appends a text column to the table.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <param name="name">Column title text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <param name="textModelColumn">Column that holds the text to be displayed.#uiTableValueTypeString</param>
        /// <param name="textEditableModelColumn">
        /// <para>Column that defines whether or not the text is editable.#uiTableValueTypeInt `TRUE` to make text editable, `FALSE`</para>
        /// <para>otherwise.`uiTableModelColumnNeverEditable` to make all rows never editable.`uiTableModelColumnAlwaysEditable` to make all rows always editable.</para>
        /// </param>
        /// <param name="textParams">Text display settings, `NULL` to use defaults.</param>
        public static void UiTableAppendTextColumn(libui.UiTable t, char8* name, int32 textModelColumn, int32 textEditableModelColumn, libui.UiTableTextColumnOptionalParams textParams)
        {
            var __arg0 = t == null ? null : t.__Instance;
            var __arg4 = textParams == null ? null : textParams.__Instance;
            __Internal.UiTableAppendTextColumn(__arg0, name, textModelColumn, textEditableModelColumn, __arg4);
        }

        /// <summary>Appends an image column to the table.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <param name="name">Column title text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <param name="imageModelColumn">Column that holds the images to be displayed.#uiTableValueTypeImage</param>
        /// <remarks>
        /// <para>Images are drawn at icon size, using the representation that best fits the</para>
        /// <para>pixel density of the screen.</para>
        /// </remarks>
        public static void UiTableAppendImageColumn(libui.UiTable t, char8* name, int32 imageModelColumn)
        {
            var __arg0 = t == null ? null : t.__Instance;
            __Internal.UiTableAppendImageColumn(__arg0, name, imageModelColumn);
        }

        /// <summary>Appends a column to the table that displays both an image and text.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <param name="name">Column title text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <param name="imageModelColumn">Column that holds the images to be displayed.#uiTableValueTypeImage</param>
        /// <param name="textModelColumn">Column that holds the text to be displayed.#uiTableValueTypeString</param>
        /// <param name="textEditableModelColumn">Column that defines whether or not the text is editable.#uiTableValueTypeInt `TRUE` to make text editable, `FALSE` otherwise.`uiTableModelColumnNeverEditable` to make all rows never editable.`uiTableModelColumnAlwaysEditable` to make all rows always editable.</param>
        /// <param name="textParams">Text display settings, `NULL` to use defaults.</param>
        /// <remarks>
        /// <para>Images are drawn at icon size, using the representation that best fits the</para>
        /// <para>pixel density of the screen.</para>
        /// </remarks>
        public static void UiTableAppendImageTextColumn(libui.UiTable t, char8* name, int32 imageModelColumn, int32 textModelColumn, int32 textEditableModelColumn, libui.UiTableTextColumnOptionalParams textParams)
        {
            var __arg0 = t == null ? null : t.__Instance;
            var __arg5 = textParams == null ? null : textParams.__Instance;
            __Internal.UiTableAppendImageTextColumn(__arg0, name, imageModelColumn, textModelColumn, textEditableModelColumn, __arg5);
        }

        /// <summary>Appends a column to the table containing a checkbox.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <param name="name">Column title text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <param name="checkboxModelColumn">Column that holds the data to be displayed.#uiTableValueTypeInt `TRUE` for a checked checkbox, `FALSE` otherwise.</param>
        /// <param name="checkboxEditableModelColumn">Column that defines whether or not the checkbox is editable.#uiTableValueTypeInt `TRUE` to make checkbox editable, `FALSE` otherwise.`uiTableModelColumnNeverEditable` to make all rows never editable.`uiTableModelColumnAlwaysEditable` to make all rows always editable.</param>
        public static void UiTableAppendCheckboxColumn(libui.UiTable t, char8* name, int32 checkboxModelColumn, int32 checkboxEditableModelColumn)
        {
            var __arg0 = t == null ? null : t.__Instance;
            __Internal.UiTableAppendCheckboxColumn(__arg0, name, checkboxModelColumn, checkboxEditableModelColumn);
        }

        /// <summary>Appends a column to the table containing a checkbox and text.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <param name="name">Column title text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <param name="checkboxModelColumn">
        /// <para>Column that holds the data to be displayed.#uiTableValueTypeInt</para>
        /// <para>`TRUE` for a checked checkbox, `FALSE` otherwise.</para>
        /// </param>
        /// <param name="checkboxEditableModelColumn">Column that defines whether or not the checkbox is editable.#uiTableValueTypeInt `TRUE` to make checkbox editable, `FALSE` otherwise.`uiTableModelColumnNeverEditable` to make all rows never editable.`uiTableModelColumnAlwaysEditable` to make all rows always editable.</param>
        /// <param name="textModelColumn">Column that holds the text to be displayed.#uiTableValueTypeString</param>
        /// <param name="textEditableModelColumn">Column that defines whether or not the text is editable.#uiTableValueTypeInt `TRUE` to make text editable, `FALSE` otherwise.`uiTableModelColumnNeverEditable` to make all rows never editable.`uiTableModelColumnAlwaysEditable` to make all rows always editable.</param>
        /// <param name="textParams">Text display settings, `NULL` to use defaults.</param>
        public static void UiTableAppendCheckboxTextColumn(libui.UiTable t, char8* name, int32 checkboxModelColumn, int32 checkboxEditableModelColumn, int32 textModelColumn, int32 textEditableModelColumn, libui.UiTableTextColumnOptionalParams textParams)
        {
            var __arg0 = t == null ? null : t.__Instance;
            var __arg6 = textParams == null ? null : textParams.__Instance;
            __Internal.UiTableAppendCheckboxTextColumn(__arg0, name, checkboxModelColumn, checkboxEditableModelColumn, textModelColumn, textEditableModelColumn, __arg6);
        }

        /// <summary>Appends a column to the table containing a progress bar.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <param name="name">Column title text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <param name="progressModelColumn">
        /// <para>Column that holds the data to be displayed.#uiTableValueTypeInt Integer in range of `[-1, 100]`, see uiProgressBar</para>
        /// <para>for details.</para>
        /// </param>
        /// <remarks>
        /// <para>The workings and valid range are exactly the same as that of uiProgressBar.</para>
        /// <para>uiProgressBar</para>
        /// </remarks>
        public static void UiTableAppendProgressBarColumn(libui.UiTable t, char8* name, int32 progressModelColumn)
        {
            var __arg0 = t == null ? null : t.__Instance;
            __Internal.UiTableAppendProgressBarColumn(__arg0, name, progressModelColumn);
        }

        /// <summary>Appends a column to the table containing a button.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <param name="name">Column title text.A valid, `NUL` terminated UTF-8 string.Data is copied internally. Ownership is not transferred.</param>
        /// <param name="buttonModelColumn">Column that holds the button text to be displayed.#uiTableValueTypeString</param>
        /// <param name="buttonClickableModelColumn">Column that defines whether or not the button is clickable.#uiTableValueTypeInt `TRUE` to make button clickable, `FALSE` otherwise.`uiTableModelColumnNeverEditable` to make all rows never clickable.`uiTableModelColumnAlwaysEditable` to make all rows always clickable.</param>
        /// <remarks>
        /// <para>Button clicks are signaled to the uiTableModelHandler via a call to</para>
        /// <para>SetCellValue() with a value of `NULL` for the</para>
        /// <para>CellValue() must return the button text to display.</para>
        /// </remarks>
        public static void UiTableAppendButtonColumn(libui.UiTable t, char8* name, int32 buttonModelColumn, int32 buttonClickableModelColumn)
        {
            var __arg0 = t == null ? null : t.__Instance;
            __Internal.UiTableAppendButtonColumn(__arg0, name, buttonModelColumn, buttonClickableModelColumn);
        }

        /// <summary>Returns whether or not the table header is visible.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <remarks>`TRUE` if visible, `FALSE` otherwise. [Default `TRUE`]</remarks>
        public static int32 UiTableHeaderVisible(libui.UiTable t)
        {
            var __arg0 = t == null ? null : t.__Instance;
            var ___ret = __Internal.UiTableHeaderVisible(__arg0);
            return ___ret;
        }

        /// <summary>Sets whether or not the table header is visible.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <param name="visible">`TRUE` to show header, `FALSE` to hide header.</param>
        public static void UiTableHeaderSetVisible(libui.UiTable t, int32 visible)
        {
            var __arg0 = t == null ? null : t.__Instance;
            __Internal.UiTableHeaderSetVisible(__arg0, visible);
        }

        /// <summary>Creates a new table.</summary>
        /// <param name="params">Table parameters.</param>
        /// <remarks>A new uiTable instance.</remarks>
        public static libui.UiTable UiNewTable(libui.UiTableParams _params)
        {
            var __arg0 = _params == null ? null : _params.__Instance;
            var ___ret = __Internal.UiNewTable(__arg0);
            var __result0 = libui.UiTable.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Registers a callback for when the user single clicks a table row.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that triggered the callback.Row index that was clicked.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>Only one callback can be registered at a time.</remarks>
        public static void UiTableOnRowClicked(libui.UiTable t, libui.Delegates.Action___IntPtr_int___IntPtr f, __IntPtr data)
        {
            var __arg0 = t == null ? null : t.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiTableOnRowClicked(__arg0, __arg1, data);
        }

        /// <summary>Registers a callback for when the user double clicks a table row.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that triggered the callback.Row index that was double clicked.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>
        /// <para>The double click callback is always preceded by one uiTableOnRowClicked() callback.</para>
        /// <para>For unix systems linking against `GTK&lt;3.14` the preceding uiTableOnRowClicked()</para>
        /// <para>callback will be triggered twice.</para>
        /// <para>Only one callback can be registered at a time.</para>
        /// </remarks>
        public static void UiTableOnRowDoubleClicked(libui.UiTable t, libui.Delegates.Action___IntPtr_int___IntPtr f, __IntPtr data)
        {
            var __arg0 = t == null ? null : t.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiTableOnRowDoubleClicked(__arg0, __arg1, data);
        }

        /// <summary>Sets the column's sort indicator displayed in the table header.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <param name="column">Column index.</param>
        /// <param name="indicator">Sort indicator.</param>
        /// <remarks>
        /// <para>Use this to display appropriate arrows in the table header to indicate a</para>
        /// <para>sort direction.</para>
        /// <para>Setting the indicator is purely visual and does not perform any sorting.</para>
        /// </remarks>
        public static void UiTableHeaderSetSortIndicator(libui.UiTable t, int32 column, uint32 indicator)
        {
            var __arg0 = t == null ? null : t.__Instance;
            __Internal.UiTableHeaderSetSortIndicator(__arg0, column, indicator);
        }

        /// <summary>Returns the column's sort indicator displayed in the table header.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <param name="column">Column index.</param>
        /// <remarks>The current sort indicator. [Default: `uiSortIndicatorNone`]</remarks>
        public static uint32 UiTableHeaderSortIndicator(libui.UiTable t, int32 column)
        {
            var __arg0 = t == null ? null : t.__Instance;
            var ___ret = __Internal.UiTableHeaderSortIndicator(__arg0, column);
            return ___ret;
        }

        /// <summary>Registers a callback for when a table column header is clicked.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that triggered the callback.Column index that was clicked.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>Only one callback can be registered at a time.</remarks>
        public static void UiTableHeaderOnClicked(libui.UiTable t, libui.Delegates.Action___IntPtr_int___IntPtr f, __IntPtr data)
        {
            var __arg0 = t == null ? null : t.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiTableHeaderOnClicked(__arg0, __arg1, data);
        }

        /// <summary>Returns the table column width.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <param name="column">Column index.</param>
        /// <remarks>Column width in pixels.</remarks>
        public static int32 UiTableColumnWidth(libui.UiTable t, int32 column)
        {
            var __arg0 = t == null ? null : t.__Instance;
            var ___ret = __Internal.UiTableColumnWidth(__arg0, column);
            return ___ret;
        }

        /// <summary>Sets the table column width.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <param name="column">Column index.</param>
        /// <param name="width">
        /// <para>Column width to set in pixels, `-1` to restore automatic</para>
        /// <para>column sizing.</para>
        /// </param>
        /// <remarks>
        /// <para>Setting the width to `-1` will restore automatic column sizing matching</para>
        /// <para>either the width of the content or column header (which ever one is bigger).</para>
        /// <para>Darwin currently only resizes to the column header width on `-1`.</para>
        /// </remarks>
        public static void UiTableColumnSetWidth(libui.UiTable t, int32 column, int32 width)
        {
            var __arg0 = t == null ? null : t.__Instance;
            __Internal.UiTableColumnSetWidth(__arg0, column, width);
        }

        /// <summary>Returns the table selection mode.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <remarks>The table selection mode. [Default `uiTableSelectionModeZeroOrOne`]</remarks>
        public static uint32 UiTableGetSelectionMode(libui.UiTable t)
        {
            var __arg0 = t == null ? null : t.__Instance;
            var ___ret = __Internal.UiTableGetSelectionMode(__arg0);
            return ___ret;
        }

        /// <summary>Sets the table selection mode.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <param name="mode">Table selection mode to set.</param>
        /// <remarks>
        /// <para>All rows will be deselected if the existing selection is illegal</para>
        /// <para>in the new selection mode.</para>
        /// </remarks>
        public static void UiTableSetSelectionMode(libui.UiTable t, uint32 mode)
        {
            var __arg0 = t == null ? null : t.__Instance;
            __Internal.UiTableSetSelectionMode(__arg0, mode);
        }

        /// <summary>Registers a callback for when the table selection changed.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <param name="f">Callback function.Back reference to the instance that triggered the callback.User data registered with the sender instance.</param>
        /// <param name="data">User data to be passed to the callback.</param>
        /// <remarks>
        /// <para>The callback is not triggered when calling uiTableSetSelection() or</para>
        /// <para>when needing to clear the selection on uiTableSetSelectionMode().</para>
        /// <para>Only one callback can be registered at a time.</para>
        /// </remarks>
        public static void UiTableOnSelectionChanged(libui.UiTable t, libui.Delegates.Action___IntPtr___IntPtr f, __IntPtr data)
        {
            var __arg0 = t == null ? null : t.__Instance;
            var __arg1 = f == null ? null : f.GetFuncPtr();
            __Internal.UiTableOnSelectionChanged(__arg0, __arg1, data);
        }

        /// <summary>Returns the current table selection.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <remarks>
        /// <para>The number of selected rows and corresponding row indices.Caller is responsible for freeing the data with `uiFreeTableSelection()`.</para>
        /// <para>For empty selections the `Rows` pointer will be NULL.</para>
        /// </remarks>
        public static libui.UiTableSelection UiTableGetSelection(libui.UiTable t)
        {
            var __arg0 = t == null ? null : t.__Instance;
            var ___ret = __Internal.UiTableGetSelection(__arg0);
            var __result0 = libui.UiTableSelection.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        /// <summary>Sets the current table selection clearing any previous selection.</summary>
        /// <param name="t">uiTable instance.</param>
        /// <param name="sel">Table selection.Data is copied internally. Ownership is not transferred.</param>
        /// <remarks>
        /// <para>Selecting more rows than the selection mode allows for results in nothing happening.</para>
        /// <para>For empty selections the Rows pointer is never accessed.</para>
        /// </remarks>
        public static void UiTableSetSelection(libui.UiTable t, libui.UiTableSelection sel)
        {
            var __arg0 = t == null ? null : t.__Instance;
            var __arg1 = sel == null ? null : sel.__Instance;
            __Internal.UiTableSetSelection(__arg0, __arg1);
        }

        /// <summary>Frees the given uiTableSelection and all it's resources.</summary>
        /// <param name="s">uiTableSelection instance.</param>
        public static void UiFreeTableSelection(libui.UiTableSelection s)
        {
            var __arg0 = s == null ? null : s.__Instance;
            __Internal.UiFreeTableSelection(__arg0);
        }
    }

    namespace Delegates
    {
        public delegate void Action___IntPtr(__IntPtr __0);

        public delegate uint64 Func_ulong___IntPtr(__IntPtr __0);

        public delegate __IntPtr Func___IntPtr___IntPtr(__IntPtr __0);

        public delegate void Action___IntPtr___IntPtr(__IntPtr __0, __IntPtr __1);

        public delegate int32 Func_int___IntPtr(__IntPtr __0);

        public delegate void Action___IntPtr___IntPtr___IntPtr(__IntPtr __0, __IntPtr __1, __IntPtr __2);

        public delegate void Action___IntPtr___IntPtr_int(__IntPtr __0, __IntPtr __1, int32 left);

        public delegate int32 Func_int___IntPtr___IntPtr___IntPtr(__IntPtr __0, __IntPtr __1, __IntPtr __2);

        public delegate int32 Func_int___IntPtr___IntPtr(__IntPtr __0, __IntPtr __1);

        public delegate uint32 Func_uint32___IntPtr___IntPtr_int(__IntPtr __0, __IntPtr __1, int32 column);

        public delegate __IntPtr Func___IntPtr___IntPtr___IntPtr_int_int(__IntPtr mh, __IntPtr m, int32 row, int32 column);

        public delegate void Action___IntPtr___IntPtr_int_int___IntPtr(__IntPtr __0, __IntPtr __1, int32 __2, int32 __3, __IntPtr __4);

        public delegate void Action___IntPtr_int___IntPtr(__IntPtr t, int32 row, __IntPtr data);
    }
}
